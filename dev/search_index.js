var documenterSearchIndex = {"docs":
[{"location":"functions/Partition/#Recursive-Graph-Partitioning","page":"Recursive Graph Partitioning","title":"Recursive Graph Partitioning","text":"","category":"section"},{"location":"functions/Partition/","page":"Recursive Graph Partitioning","title":"Recursive Graph Partitioning","text":"Pages = [\"Partition.md\"]","category":"page"},{"location":"functions/Partition/#Graph-Partition","page":"Recursive Graph Partitioning","title":"Graph Partition","text":"","category":"section"},{"location":"functions/Partition/#MultiscaleGraphSignalTransforms.GraphPartition.GraphPart","page":"Recursive Graph Partitioning","title":"MultiscaleGraphSignalTransforms.GraphPartition.GraphPart","text":"GP = GraphPart(ind::Vector{Int}, rs::Matrix{Int}, tag::Matrix{Int}, compinfo::Matrix{Int}, rsf2c::Matrix{Int}, tagf2c::Matrix{Int}, compinfof2c::Matrix{Int}, inds::Matrix{Int}, method::Vector{Symbol})\n\nis a data structure for a GraphPart object containing the following fields:\n\nind::Vector{Int}: ordering of the indices on the finest level\nrs::Matrix{Int}: regionstarInt (coarse-to-fine) <==> the index in ind of the first point in region number i is rs[i]\ntag::Matrix{Int}: tag info for the GHWT coarse-to-fine basis\ncompinfo::Matrix{Int}: indicates whether the coefficient was formed from 2 coefficenInt (value is nonzero) or from only 1 coefficient (value is zero); when a scaling and Haar-like coefficient are formed, their corresponding values in compinfo indicate the number of nodes in each of the 2 subregions\nrsf2c::Matrix{Int}: the fine-to-coarse version of rs\ntagf2c::Matrix{Int}: the fine-to-coarse version of tag\ncompinfof2c::Matrix{Int}: the fine-to-coarse version of compinfo\ninds::Matrix{Int}: ordering of the indices on all levels\nmethod::Symbol: how the partition tree was constructed\n\nThe unsigned integer depends on the size of the underlying graph.\n\nCopyright 2015 The RegenInt of the University of California\n\nImplemented by Jeff Irion (Adviser: Dr. Naoki Saito) | Translated and modified by Naoki Saito, Feb. 7, 2017 Revised for two parameters by Naoki Saito, Feb. 24, 2017\n\n\n\n\n\n","category":"type"},{"location":"functions/Partition/#MultiscaleGraphSignalTransforms.GraphPartition.partition_tree_fiedler-Tuple{GraphSig}","page":"Recursive Graph Partitioning","title":"MultiscaleGraphSignalTransforms.GraphPartition.partition_tree_fiedler","text":"GP = partition_tree_fiedler(G::GraphSig; method::Symbol = :Lrw, swapRegion::Bool = true)\n\nGenerate a partition tree for a graph using the Fiedler vector of either  L (the unnormalized Laplacian) or L_rw (the random-walk normalized  Laplacian).\n\nInput ArgumenInt\n\nG::GraphSig: an input GraphSig object\nmethod::Symbol: how the partition tree was constructed (default: :Lrw)\nswapRegion::Bool: swap the child regions based on the sum of the subgraphs' edge weights (default: true)\n\nOutput Argument\n\nGP::GraphPart: an ouput GraphPart object\n\nCopyright 2015 The RegenInt of the University of California\n\nImplemented by Jeff Irion (Adviser: Dr. Naoki Saito) | Translated and modified by Naoki Saito, Feb. 7, 2017\n\n\n\n\n\n","category":"method"},{"location":"functions/Partition/#MultiscaleGraphSignalTransforms.GraphPartition.partition_tree_matrixDhillon-Tuple{Matrix{Float64}}","page":"Recursive Graph Partitioning","title":"MultiscaleGraphSignalTransforms.GraphPartition.partition_tree_matrixDhillon","text":"GProws, GPcols = partition_tree_matrixDhillon(matrix::Matrix{Float64})\n\nRecursively partition the rows and columns of the matrix using the\nbipartite model proposed by Dhillon in \"Co-clustering documents and words\nusing Bipartite Spectral Graph Partitioning\"\n\nInput Arguments\n\nmatrix::Matrix{Float64}: an input matrix\n\nOutput Argument\n\nGProws::GraphPart: partitioning using rows as samples\nGPcols::GraphPart: partitioning using cols as samples\n\n\n\n\n\n","category":"method"},{"location":"functions/Partition/#BasisSpec-Object","page":"Recursive Graph Partitioning","title":"BasisSpec Object","text":"","category":"section"},{"location":"functions/Partition/#MultiscaleGraphSignalTransforms.BasisSpecification.BasisSpec","page":"Recursive Graph Partitioning","title":"MultiscaleGraphSignalTransforms.BasisSpecification.BasisSpec","text":"BS = BasisSpec(dvec, dvec_loc, c2f, description)\n\nis a data structure for a BasisSpec object contaning the following fields:\n\nlevlist::Vector{Tuple{Int, Int}}: the integer sequence that specifies a particular basis\nc2f::Bool: if true (default), this indicates that the basis comes from the coarse-to-fine dictionary; if false, this indicates that the basis comes from the fine-to-coarse dictionary\ndescription::String: a description of the specified basis\n\nCopyright 2015 The Regents of the University of California\n\nImplemented by Jeff Irion (Adviser: Dr. Naoki Saito) | Translated to julia and revised by Naoki Saito, Feb. 22, 2017 Modified by Yiqun Shao, May. 20, 2018\n\n\n\n\n\n","category":"type"},{"location":"functions/NGWD/#Natural-Graph-Wavelet-Dictionaries","page":"Natural Graph Wavelet Dictionaries","title":"Natural Graph Wavelet Dictionaries","text":"","category":"section"},{"location":"functions/NGWD/","page":"Natural Graph Wavelet Dictionaries","title":"Natural Graph Wavelet Dictionaries","text":"Pages = [\"NGWD.md\"]","category":"page"},{"location":"functions/NGWD/#Metrics-of-graph-Laplacian-eigenvectors","page":"Natural Graph Wavelet Dictionaries","title":"Metrics of graph Laplacian eigenvectors","text":"","category":"section"},{"location":"functions/NGWD/#MultiscaleGraphSignalTransforms.natural_eigdist-Tuple{Any, Any, Any}","page":"Natural Graph Wavelet Dictionaries","title":"MultiscaleGraphSignalTransforms.natural_eigdist","text":"natural_eigdist(ùöΩ, ùõå, Q; Œ± = 1.0, T = :Inf,\n                input_format = :zero_measures, distance = :DAG,\n                edge_weight = 1, edge_length = 1)\n\ncompute natural distances between graph Laplacian eigenvectors.\n\nInput Arguments\n\nùöΩ::Matrix{Float64}: matrix of (weighted) graph Laplacian eigenvectors.\nùõå::Vector{Float64}: vector of eigenvalues.\nQ::Matrix{Float64}: unweighted incidence matrix of the graph.\nŒ±::Float64: ROT parameter. (default: 1.0)\nT::Any: TSD parameter, i.e., the stopping time T in K_functional (default: :Inf)\ninput_format::Symbol: options: :zero_measures, :pmf1 and :pmf2 (default: :zero_measures)\ndistance::Symbol: options: :ROT, :HAD, :DAG and :TSD (default: :DAG)\nedg_length::Any: vector of edge lengths (default: 1 represents unweighted graphs)\nedge_weight::Any: the weights vector, which stores the affinity weight of   each edge (default: 1 represents unweighted graphs).\n\nOutput Argument\n\ndis::Matrix{Float64}: the distance matrix, dis[i,j] = d(ùúô·µ¢‚Çã‚ÇÅ, ùúô‚±º‚Çã‚ÇÅ).\n\n\n\n\n\n","category":"method"},{"location":"functions/NGWD/#MultiscaleGraphSignalTransforms.ROT_Distance-Tuple{Any, Any, SparseArrays.SparseMatrixCSC{Int64, Int64}}","page":"Natural Graph Wavelet Dictionaries","title":"MultiscaleGraphSignalTransforms.ROT_Distance","text":"ROT_Distance(A, B, Q; edge_length = 1, Œ± = 1.0)\n\ncomputes the ROT distance matrix from A's column vectors to B's column vectors. If A, B are vector inputs, then it also returns the cost value and the optimal transport plan.\n\nInput Argument\n\nA::Any: a vector or matrix whose columns are initial probability measures.\nB::Any: a vector or matrix whose columns are terminal probability measures.\nQ::SparseMatrixCSC{Int64,Int64}: the unweighted incidence matrix of the graph.\nedge_length::Any: the length vector (default: 1 represents unweighted graphs)\nŒ±::Float64: default is 1.0. ROT parameter.\nretPlan::Bool: an indicator if return the optimal plan (default: false)\n\nOutput Argument\n\ndis::Matrix{Float64}: distance matrix, dis[i,j] = d_{ROT}(a·µ¢, b‚±º; Œ±).\n\n\n\n\n\n","category":"method"},{"location":"functions/NGWD/#MultiscaleGraphSignalTransforms.eigROT_Distance-Tuple{Matrix{Float64}, SparseArrays.SparseMatrixCSC{Int64, Int64}}","page":"Natural Graph Wavelet Dictionaries","title":"MultiscaleGraphSignalTransforms.eigROT_Distance","text":"eigROT_Distance(P, Q; edge_length = 1, Œ± = 1.0)\n\ncomputes the ROT distance matrix of P's column vectors on a graph.\n\nInput Argument\n\nP::Matrix{Float64}: a matrix whose columns are vector measures with the same total mass.\nQ::SparseMatrixCSC{Int64,Int64}: the unweighted incidence matrix of the graph.\nedge_length::Any: the length vector (default: 1 represents unweighted graphs)\nŒ±::Float64: default is 1.0. ROT parameter.\n\nOutput Argument\n\ndis::Matrix{Float64}: distance matrix, dis[i,j] = d_{ROT}(p·µ¢, p‚±º; Œ±).\n\n\n\n\n\n","category":"method"},{"location":"functions/NGWD/#MultiscaleGraphSignalTransforms.eigsROT_Distance-Tuple{Matrix{Float64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, Matrix{Float64}}","page":"Natural Graph Wavelet Dictionaries","title":"MultiscaleGraphSignalTransforms.eigsROT_Distance","text":"eigsROT_Distance(P::Matrix{Float64}, W::SparseMatrixCSC{Float64, Int64}, X::Matrix{Float64}; Œ±::Float64 = 1.0)\n\ncomputes the sROT distance matrix of P's column vectors on a (unweighted) tree.\n\nInput Argument\n\nP::Matrix{Float64}: a matrix whose columns are vector measures with the same total mass.\nW::SparseMatrixCSC{Float64, Int64}: the weight matrix of the tree.\nX::Matrix{Float64}: the node positions (i-th row represents node i's location)\nŒ±::Float64: default is 1.0. ROT parameter.\n\nOutput Argument\n\ndist_sROT::Matrix{Float64}: distance matrix, distsROT[i,j] = d{sROT}(p·µ¢, p‚±º; Œ±).\nWs::SparseMatrixCSC{Float64, Int64}: the weight matrix of the simplified tree.\nXs::Matrix{Float64}: the node locations of the simplified tree\nùöØ::Matrix{Float64}: the shortened pmfs from P.\n\n\n\n\n\n","category":"method"},{"location":"functions/NGWD/#MultiscaleGraphSignalTransforms.find_subgraph_inds-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"Natural Graph Wavelet Dictionaries","title":"MultiscaleGraphSignalTransforms.find_subgraph_inds","text":"find_subgraph_inds(Wc::SparseMatrixCSC{Float64, Int64})\n\nfind all subgraph indices of a tree. (subgraph includes: branches and junctions)\n\nInput Argument\n\nWc::SparseMatrixCSC{Float64, Int64}: the weight matrix of the tree chopped by   the junctions.\n\nOutput Argument\n\nInd::Matrix{Float64}: a matrix whose columns represent the subgraph node   indices in binary form.\n\n\n\n\n\n","category":"method"},{"location":"functions/NGWD/#MultiscaleGraphSignalTransforms.eigHAD_Affinity-Tuple{Any, Any}","page":"Natural Graph Wavelet Dictionaries","title":"MultiscaleGraphSignalTransforms.eigHAD_Affinity","text":"eigHAD_Affinity(ùöΩ, ùõå; indexEigs = 1:size(ùöΩ,2))\n\nEIGHAD_AFFINITY compute Hadamard (HAD) affinity between pairwise graph Laplacian eigenvectors.\n\nInput Arguments\n\nùöΩ::Matrix{Float64}: matrix of graph Laplacian eigenvectors, ùúô‚±º‚Çã‚ÇÅ (j = 1,...,size(ùöΩ,1)).\nùõå::Array{Float64}: array of eigenvalues. (ascending order)\nindexEigs::Int: default is all eigenvectors, indices of eigenvectors considered.\n\nOutput Argument\n\nA::Matrix{Float64}: a numEigs x numEigs affinity matrix, A[i,j] = a_HAD(ùúô·µ¢‚Çã‚ÇÅ, ùúô‚±º‚Çã‚ÇÅ).\n\n\n\n\n\n","category":"method"},{"location":"functions/NGWD/#MultiscaleGraphSignalTransforms.eigHAD_Distance-Tuple{Any, Any}","page":"Natural Graph Wavelet Dictionaries","title":"MultiscaleGraphSignalTransforms.eigHAD_Distance","text":"eigHAD_Distance(ùöΩ, ùõå; indexEigs = 1:size(ùöΩ,2))\n\ncompute HAD \"distance\" (not really a distance) between pairwise graph Laplacian eigenvectors, i.e., dHAD(ùúô·µ¢‚Çã‚ÇÅ, ùúô‚±º‚Çã‚ÇÅ) = ‚àö(1 - aHAD(ùúô·µ¢‚Çã‚ÇÅ, ùúô‚±º‚Çã‚ÇÅ)¬≤).\n\nInput Arguments\n\nùöΩ::Matrix{Float64}: matrix of graph Laplacian eigenvectors, ùúô‚±º‚Çã‚ÇÅ (j = 1,...,size(ùöΩ,1)).\nùõå::Array{Float64}: array of eigenvalues. (ascending order)\nindexEigs::Int: default is all eigenvectors, indices of eigenvectors considered.\n\nOutput Argument\n\ndis::Matrix{Float64}: the HAD distance matrix, dis[i,j] = d_HAD(ùúô·µ¢‚Çã‚ÇÅ, ùúô‚±º‚Çã‚ÇÅ).\n\n\n\n\n\n","category":"method"},{"location":"functions/NGWD/#MultiscaleGraphSignalTransforms.eigDAG_Distance-Tuple{Any, Any, Any}","page":"Natural Graph Wavelet Dictionaries","title":"MultiscaleGraphSignalTransforms.eigDAG_Distance","text":"eigDAG_Distance(ùöΩ, Q, numEigs; edge_weights = 1)\n\ncompute DAG distances between pairwise graph Laplacian eigenvectors.\n\nInput Arguments\n\nùöΩ::Matrix{Float64}: matrix of graph Laplacian eigenvectors, ùúô‚±º‚Çã‚ÇÅ (j = 1,...,size(ùöΩ,1)).\nQ::Matrix{Float64}: incidence matrix of the graph.\nnumEigs::Int64: number of eigenvectors considered.\nedge_weight::Any: default value is 1, stands for unweighted graph   (i.e., all edge weights equal to 1). For weighted graph, edge_weight is the   weights vector, which stores the affinity weight of each edge.\n\nOutput Argument\n\ndis::Matrix{Float64}: a numEigs x numEigs distance matrix, dis[i,j] = d_DAG(ùúô·µ¢‚Çã‚ÇÅ, ùúô‚±º‚Çã‚ÇÅ).\n\n\n\n\n\n","category":"method"},{"location":"functions/NGWD/#MultiscaleGraphSignalTransforms.K_functional-Tuple{Vector{Float64}, Vector{Float64}, Matrix{Float64}, Matrix{Float64}, Vector{Float64}}","page":"Natural Graph Wavelet Dictionaries","title":"MultiscaleGraphSignalTransforms.K_functional","text":"K_functional(ùê©::Vector{Float64}, ùê™::Vector{Float64}, ùöΩ::Matrix{Float64},\n             ‚àáùöΩ::Matrix{Float64}, ùõå::Vector{Float64}; length::Any = 1,\n             T::Any = :Inf, dt::Float64 = 0.5/maximum(ùõå), tol::Float64 = 1e-5)\n\ncomputes the K_functional between two vector meassures ùê© and ùê™ on a graph.\n\nInput Argument\n\nùê©::Vector{Float64}: the source vector measure.\nùê™::Vector{Float64}: the destination vector measure.\nùöΩ::Matrix{Float64}: matrix of the unweighted graph Laplacian eigenvectors.\n‚àáùöΩ::Matrix{Float64}: gradient of unweighted graph Laplacian eigenvectors.\nùõå::Vector{Float64}: vector of eigenvalues.\nlength::Any: vector of edge lengths (default: 1 represents unweighted graphs)\nT::Any: the stopping time T in K_functional (default: :Inf)\ntol::Float64: tolerance for convergence (default: 1e-5)\n\nOutput Argument\n\nK::Float64: TSD distance d_{TSD}(p, q; T).\nE::Float64: an estimated upper bound on the absolute error. In general,   E <= tol * norm(K).\n\n\n\n\n\n","category":"method"},{"location":"functions/NGWD/#MultiscaleGraphSignalTransforms.eigTSD_Distance-Tuple{Matrix{Float64}, Matrix{Float64}, Vector{Float64}, SparseArrays.SparseMatrixCSC{Int64, Int64}}","page":"Natural Graph Wavelet Dictionaries","title":"MultiscaleGraphSignalTransforms.eigTSD_Distance","text":"eigTSD_Distance(P::Matrix{Float64}, ùöΩ::Matrix{Float64}, ùõå::Vector{Float64},\n                Q::SparseMatrixCSC{Int64,Int64}; length::Any = 1,\n                T::Any = :Inf, tol::Float64 = 1e-5)\n\ncomputes the TSD distance matrix of P's column vectors on a graph.\n\nInput Argument\n\nP::Matrix{Float64}: vector measures with the same total mass 0.\nùöΩ::Matrix{Float64}: matrix of the unweighted graph Laplacian eigenvectors.\nùõå::Vector{Float64}: vector of eigenvalues.\nQ::SparseMatrixCSC{Int64,Int64}: the unweighted incidence matrix.\nlength::Any: vector of edge lengths (default: 1 represents unweighted graphs)\nT::Any: the stopping time T in K_functional (default: :Inf)\ntol::Float64: tolerance for integral convergence (default: 1e-5)\n\nOutput Argument\n\ndis::Matrix{Float64}: distance matrix, d_{TSD}(œÜ·µ¢, œÜ‚±º; T).\n\n\n\n\n\n","category":"method"},{"location":"functions/NGWD/#Dual-Graph","page":"Natural Graph Wavelet Dictionaries","title":"Dual Graph","text":"","category":"section"},{"location":"functions/NGWD/#MultiscaleGraphSignalTransforms.dualgraph","page":"Natural Graph Wavelet Dictionaries","title":"MultiscaleGraphSignalTransforms.dualgraph","text":"dualgraph(dist::Matrix{Float64}; method::Symbol = :inverse, œÉ::Float64 = 1.0)\n\nbuild the dual graph's weight matrix based on the given non-trivial eigenvector metric.\n\nInput Arguments\n\ndist::Matrix{Float64}: eigenvector distance matrix\nmethod::Symbol: default is by taking inverse of the distance between   eigenvectors. Ways to build the dual graph edge weights. Option: :inverse,   :gaussian.\nœÉ::Float64: default is 1.0. Gaussian variance parameter.\n\nOutput Argument\n\nG_star::GraphSig: A GraphSig object containing the weight matrix of the   dual graph.\n\n\n\n\n\n","category":"function"},{"location":"functions/NGWD/#Varimax-Natural-Graph-Wavelet-Packet","page":"Natural Graph Wavelet Dictionaries","title":"Varimax Natural Graph Wavelet Packet","text":"","category":"section"},{"location":"functions/NGWD/#MultiscaleGraphSignalTransforms.varimax","page":"Natural Graph Wavelet Dictionaries","title":"MultiscaleGraphSignalTransforms.varimax","text":"varimax(A; gamma = 1.0, minit = 20, maxit = 1000, reltol = 1e-12)\n\nVARIMAX perform varimax (or quartimax, equamax, parsimax) rotation to the column vectors of the input matrix.\n\nInput Arguments\n\nA::Matrix{Float64}: input matrix, whose column vectors are to be rotated. d, m = size(A).\ngamma::Float64: default is 1. gamma = 0, 1, m/2, and d(m - 1)/(d + m - 2), corresponding to quartimax, varimax, equamax, and parsimax.\nminit::Int: default is 20. Minimum number of iterations, in case of the stopping criteria fails initially.\nmaxit::Int: default is 1000. Maximum number of iterations.\nreltol::Float64: default is 1e-12. Relative tolerance for stopping criteria.\n\nOutput Argument\n\nB::Matrix{Float64}: output matrix, whose columns are already been rotated.\n\nImplemented by Haotian Li, Aug. 20, 2019\n\n\n\n\n\n","category":"function"},{"location":"functions/NGWD/#MultiscaleGraphSignalTransforms.vm_ngwp","page":"Natural Graph Wavelet Dictionaries","title":"MultiscaleGraphSignalTransforms.vm_ngwp","text":"vm_ngwp(ùöΩ::Matrix{Float64}, GP_star::GraphPart)\n\nconstruct varimax NGWP and GP_star.tag in place.\n\nInput Arguments\n\nùöΩ::Matrix{Float64}: graph Laplacian eigenvectors ùöΩ\nGP_star::GraphPart: GraphPart object of the dual graph\n\nOutput Argument\n\nwavelet_packet::Array{Float64,3}: the varimax NGWP. The first index is for   selecting wavelets at a fixed level; the second index is for selecting the   level j; the third index is for selecting elements in the wavelet vector.\n\n\n\n\n\n","category":"function"},{"location":"functions/NGWD/#Pair-Clustering-Natural-Graph-Wavelet-Packet","page":"Natural Graph Wavelet Dictionaries","title":"Pair-Clustering Natural Graph Wavelet Packet","text":"","category":"section"},{"location":"functions/NGWD/#MultiscaleGraphSignalTransforms.pairclustering","page":"Natural Graph Wavelet Dictionaries","title":"MultiscaleGraphSignalTransforms.pairclustering","text":"pairclustering(ùöΩ::Matrix{Float64}, GP_star::GraphPart)\n\nconstruct the GraphPart object of the primal graph via pair-clustering algorithm.\n\nInput Arguments\n\nùöΩ::Matrix{Float64}: graph Laplacian eigenvectors ùöΩ\nGP_star::GraphPart: GraphPart object of the dual graph\n\nOutput Argument\n\nGP::GraphPart: GraphPart object of the primal graph via pair-clustering\n\n\n\n\n\n","category":"function"},{"location":"functions/NGWD/#MultiscaleGraphSignalTransforms.mgslp","page":"Natural Graph Wavelet Dictionaries","title":"MultiscaleGraphSignalTransforms.mgslp","text":"mgslp(A::Matrix{Float64}; tol::Float64 = 1e-12, p::Float64 = 1.0)\n\nModified Gram-Schmidt Process Orthogonalization with ‚Ñì·µñ pivoting algorithm (MGSLp)\n\nInput Arguments\n\nA::Matrix{Float64}: whose column vectors are to be orthogonalized.\n\nOutput Argument\n\nA::Matrix{Float64}: orthogonalization matrix of A's column vectors based on ‚Ñì·µñ pivoting.\n\n\n\n\n\n","category":"function"},{"location":"functions/NGWD/#MultiscaleGraphSignalTransforms.pc_ngwp","page":"Natural Graph Wavelet Dictionaries","title":"MultiscaleGraphSignalTransforms.pc_ngwp","text":"pc_ngwp(ùöΩ::Matrix{Float64}, GP_star::GraphPart, GP::GraphPart)\n\nconstruct pair-clustering NGWP and GP.tag in place.\n\nInput Arguments\n\nùöΩ::Matrix{Float64}: graph Laplacian eigenvectors ùöΩ\nGP_star::GraphPart: GraphPart object of the dual graph\nGP::GraphPart: GraphPart object of the primal graph\n\nOutput Argument\n\nwavelet_packet::Array{Float64,3}: the pair-clustering NGWP. The first   index is for selecting wavelets at a fixed level; the second index is for   selecting the level j; the third index is for selecting elements in the   wavelet vector.\n\n\n\n\n\n","category":"function"},{"location":"functions/NGWD/#Lapped-Natural-Graph-Wavelet-Packet","page":"Natural Graph Wavelet Dictionaries","title":"Lapped Natural Graph Wavelet Packet","text":"","category":"section"},{"location":"functions/NGWD/#MultiscaleGraphSignalTransforms.lp_ngwp","page":"Natural Graph Wavelet Dictionaries","title":"MultiscaleGraphSignalTransforms.lp_ngwp","text":"lp_ngwp(ùöΩ::Matrix{Float64}, W_dual::SparseMatrixCSC{Float64, Int64},\n        GP_dual::GraphPart; œµ::Float64 = 0.3)\n\nconstruct the lapped NGWP and GP.tag in place.\n\nInput Arguments\n\nùöΩ::Matrix{Float64}: graph Laplacian eigenvectors\nW_dual::SparseMatrixCSC{Float64, Int64}: weight matrix of the dual graph\nGP_dual::GraphPart: GraphPart object of the dual graph\n\nOutput Argument\n\nwavelet_packet::Array{Float64,3}: the lapped NGWP dictionary. The first   index is for selecting wavelets at a fixed level; the second index is for   selecting the level j; the third index is for selecting elements in the   wavelet vector.\n\n\n\n\n\n","category":"function"},{"location":"functions/NGWD/#Graph-Signal-Processing-via-NGWP","page":"Natural Graph Wavelet Dictionaries","title":"Graph Signal Processing via NGWP","text":"","category":"section"},{"location":"functions/NGWD/#MultiscaleGraphSignalTransforms.ngwp_analysis","page":"Natural Graph Wavelet Dictionaries","title":"MultiscaleGraphSignalTransforms.ngwp_analysis","text":"ngwp_analysis(G::GraphSig, wavelet_packet::Array{Float64,3})\n\nFor a GraphSig object G, generate the matrix of NGWP expansion coefficients.\n\nInput Arguments\n\nG::GraphSig: an input GraphSig object\nwavelet_packet::Array{Float64,3}: the varimax wavelets packet.\n\nOutput Argument\n\ndmatrix::Array{Float64,3}: the expansion coefficients matrix.\n\n\n\n\n\n","category":"function"},{"location":"functions/NGWD/#MultiscaleGraphSignalTransforms.ngwp_bestbasis","page":"Natural Graph Wavelet Dictionaries","title":"MultiscaleGraphSignalTransforms.ngwp_bestbasis","text":"(dvec_ngwp, BS_ngwp) = ngwp_bestbasis(dmatrix::Array{Float64,3}, GP_star::GraphPart;\n                                      cfspec::Any = 1.0, flatten::Any = 1.0,\n                                      j_start::Int = 1, j_end::Int = size(dmatrix, 2),\n                                      useParent::Bool = true)\n\nSelect the best basis from the matrix of NGWP expansion coefficients.\n\nInput Arguments\n\ndmatrix::Array{Float64,3}: the matrix of expansion coefficients\nGP_star::GraphPart: an input GraphPart object of the dual graph\ncfspec::Any: the specification of cost functional to be used (default = 1.0,   i.e., 1-norm)\nflatten::Any: the method for flattening vector-valued data to scalar-valued   data (default = 1.0, i.e, 1-norm)\nuseParent::Bool: the flag to indicate if we update the selected best basis   subspace to the parent when parent and child have the same cost (default = false)\n\nOutput Arguments\n\ndvec_ngwp::Matrix{Float64}: the vector of expansion coefficients corresponding   to the NGWP best basis\nBS_ngwp::BasisSpec: a BasisSpec object which specifies the NGWP best basis\n\n\n\n\n\n","category":"function"},{"location":"functions/NGWD/#MultiscaleGraphSignalTransforms.NGWP_jkl","page":"Natural Graph Wavelet Dictionaries","title":"MultiscaleGraphSignalTransforms.NGWP_jkl","text":"function NGWP_jkl(GP_star::GraphPart, drow::Int, dcol::Int)\n\nGenerate the (j,k,l) indices for the NGWP basis vector corresponding to the coefficient dmatrix(drow,dcol)\n\nInput Arguments\n\nGP_star::GraphPart: a GraphPart object of the dual grpah\ndrow::Int: the row of the expansion coefficient\ndcol::Int: the column of the expansion coefficient\n\nOutput Argument\n\nj: the level index of the expansion coefficient\nk: the subregion in dual graph's index of the expansion coefficient\nl: the tag of the expansion coefficient\n\n\n\n\n\n","category":"function"},{"location":"functions/NGWD/#Natural-Graph-Wavelet-Frame","page":"Natural Graph Wavelet Dictionaries","title":"Natural Graph Wavelet Frame","text":"","category":"section"},{"location":"functions/NGWD/#MultiscaleGraphSignalTransforms.frame_approx-Tuple{Any, Any, Any}","page":"Natural Graph Wavelet Dictionaries","title":"MultiscaleGraphSignalTransforms.frame_approx","text":"frame_approx(f, U, V; num_kept = length(f))\n\napproximate signal f by the frame U.\n\nInput Arguments\n\nf::Vector{Float64}: input graph signal\nU::Matrix{Float64}: a frame operator (matrix or dictionary)\nV::Matrix{Float64}: the dual frame operator of U\nnum_kept::Int64: number of kept coefficients (NCR)\n\nOutput Argument\n\nrel_error::Vector{Float64}: the relative errors\nf_approx::Vector{Float64}: the approximated signal\n\n\n\n\n\n","category":"method"},{"location":"functions/NGWD/#MultiscaleGraphSignalTransforms.nat_spec_filter-Tuple{Any, Any}","page":"Natural Graph Wavelet Dictionaries","title":"MultiscaleGraphSignalTransforms.nat_spec_filter","text":"nat_spec_filter(l, D; œÉ = 0.25 * maximum(D), method = :regular, thres = 0.2)\n\nassemble the natural spectral graph filter centered at the l-th eigenvector via the distance matrix D.\n\nInput Arguments\n\nl::Int64: index of the centered eigenvector\nD::Matrix{Float64}: non-trivial distance matrix of the eigenvectors\nœÉ::Float64: Gaussian window width parameter (default: 0.25 * maximum(D))\nmethod::Symbol: :regular or :reduced (default: :regular)\nthres::Float64: cutoff threshold ‚àà (0, 1).\n\nOutput Argument\n\nùõç::Vector{Float64}: the natural spectral graph filter\n\n\n\n\n\n","category":"method"},{"location":"functions/NGWD/#MultiscaleGraphSignalTransforms.ngwf_all_vectors-Tuple{Any, Any}","page":"Natural Graph Wavelet Dictionaries","title":"MultiscaleGraphSignalTransforms.ngwf_all_vectors","text":"ngwf_all_vectors(D, ùöΩ; œÉ = 0.2 * maximum(D))\n\nassemble the whole NGWF dictionary.\n\nInput Arguments\n\nD::Matrix{Float64}: non-trivial distance matrix of the eigenvectors\nùöΩ::Matrix{Float64}: graph Laplacian eigenvectors\nœÉ::Float64: Gaussian window width parameter (default: 0.25 * maximum(D))\n\nOutput Argument\n\nùì§::Matrix{Float64}: the NGWF dictionary\n\n\n\n\n\n","category":"method"},{"location":"functions/NGWD/#MultiscaleGraphSignalTransforms.rngwf_all_vectors-Tuple{Any, Any}","page":"Natural Graph Wavelet Dictionaries","title":"MultiscaleGraphSignalTransforms.rngwf_all_vectors","text":"rngwf_all_vectors(D, ùöΩ; œÉ = 0.2 * maximum(D), thres = 0.2)\n\nassemble the reduced NGWF (rNGWF) dictionary.\n\nInput Arguments\n\nD::Matrix{Float64}: non-trivial distance matrix of the eigenvectors\nùöΩ::Matrix{Float64}: graph Laplacian eigenvectors\nœÉ::Float64: Gaussian window width parameter (default: 0.25 * maximum(D))\nthres::Float64: cutoff threshold ‚àà (0, 1).\n\nOutput Argument\n\nùì§::Matrix{Float64}: the rNGWF dictionary\ndic_l2x::Dict: a dictionary to store the filtered locations by QR at the l-th   centered eigenvector\n\n\n\n\n\n","category":"method"},{"location":"functions/NGWD/#MultiscaleGraphSignalTransforms.rngwf_lx-Tuple{Any}","page":"Natural Graph Wavelet Dictionaries","title":"MultiscaleGraphSignalTransforms.rngwf_lx","text":"rngwf_lx(dic_l2x)\n\nfind the sequential subindices of rNGWF vectors.\n\nInput Arguments\n\ndic_l2x::Dict: a dictionary to store the filtered locations by QR at the l-th   centered eigenvector\n\nOutput Argument\n\nŒì::Vector{Tuple{Int64,Int64}}: the sequential subindices of rNGWF vectors.\n\n\n\n\n\n","category":"method"},{"location":"examples/P64/#p64","page":"1D Path","title":"Multiscale Graph Signal Transforms on 1D Path","text":"","category":"section"},{"location":"examples/P64/","page":"1D Path","title":"1D Path","text":"Let us use the unweighted 1D path with a synthetic signal as a simple example to demonstrate the usage of the MultiscaleGraphSignalTransforms.jl.","category":"page"},{"location":"examples/P64/#Set-up","page":"1D Path","title":"Set up","text":"","category":"section"},{"location":"examples/P64/","page":"1D Path","title":"1D Path","text":"We first construct the GraphSig and GraphPart objects of the primal graph G = P_64.","category":"page"},{"location":"examples/P64/","page":"1D Path","title":"1D Path","text":"using MultiscaleGraphSignalTransforms, Plots, LinearAlgebra\nimport WaveletsExt: wiggle\nusing Plots.PlotMeasures # hide\n\n# construct P64\nN = 64\nG = gpath(N)\n\n# compute graph Laplacian eigenvectors\nW = G.W\nL = diagm(sum(W; dims = 1)[:]) - W  # unnormalized graph Laplacian\nùõå, ùöΩ = eigen(L)\nùöΩ = ùöΩ .* sign.(ùöΩ[1,:])'\n\n# perform recursive bipartitioning of G by the Fiedler vectors of Lrw\nGP = partition_tree_fiedler(G; swapRegion = false)\n\n# use Chebyshev polynomial T‚ÇÖ(x) (x ‚àà [0, 1]) as an example signal\nG.f = reshape([16 * x^5 - 20 * x^3 + 5 * x for x in LinRange(0, 1, N)], (N, 1))\nplot(G.f; c = :black, lw = 2, legend = false, grid = false, size = (815, 300))\nxticks!([1; 8:8:64], vcat(string(\"1\"), [string(k) for k in 8:8:64])) # hide\nplot!(left_margin = 5mm) # hide","category":"page"},{"location":"examples/P64/#Graph-Signal-Processing-via-HGLET/LP-HGLET","page":"1D Path","title":"Graph Signal Processing via HGLET/LP-HGLET","text":"","category":"section"},{"location":"examples/P64/","page":"1D Path","title":"1D Path","text":"## analyze the signal via HGLET\ndmatrixH, dmatrixHrw, dmatrixHsym = HGLET_Analysis_All(G, GP)\ndvec_hglet, BS_hglet, trans_hglet = HGLET_GHWT_BestBasis(GP, dmatrixH = dmatrixH,\n    dmatrixHrw = dmatrixHrw, dmatrixHsym = dmatrixHsym, cfspec = 1)\n\n## LP-HGLET\ndmatrixsH, dmatrixsHsym = LPHGLET_Analysis_All(G, GP; œµ = 0.3)\ndvec_lphglet, BS_lphglet, trans_lphglet = HGLET_GHWT_BestBasis(GP, dmatrixH = dmatrixsH,\n    dmatrixHsym = dmatrixsHsym, cfspec = 1)\n\n# find the top 10 HGLET basis vectors\nimportant_idx = sortperm(dvec_hglet[:].^2; rev = true)\nhglet_top10 = zeros(N, 10)\nfor i in 1:10\n    w, _ = HGLET_Synthesis(reshape(spike(important_idx[i], N), (N, 1)),\n        GP, BS_hglet, G, gltype = :L)\n    hglet_top10[:, i] = w[:]\nend\nwiggle(hglet_top10; sc = 0.45)\np1 = title!(\"Top 10 HGLET basis vectors\")\n\n# find the top 10 LP-HGLET basis vectors\nimportant_idx = sortperm(dvec_lphglet[:].^2; rev = true)\nlphglet_top10 = zeros(N, 10)\nfor i in 1:10\n    w, _ = LPHGLET_Synthesis(reshape(spike(important_idx[i], N), (N, 1)),\n        GP, BS_lphglet, G; gltype = :L, œµ = 0.3)\n    lphglet_top10[:, i] = w[:]\nend\nwiggle(lphglet_top10; sc = 0.45)\np2 = title!(\"Top 10 LP-HGLET basis vectors\")\n\nplot(p1, p2, layout = Plots.grid(2, 1), size = (815, 600))\nxticks!([1; 8:8:64], vcat(string(\"1\"), [string(k) for k in 8:8:64])) # hide\nyticks!([0; 1:10], vcat(string(\"\"), [string(k) for k in 1:10])) # hide\nplot!(left_margin = 5mm) # hide","category":"page"},{"location":"examples/P64/#Graph-Signal-Processing-via-GHWT,-eGHWT,-etc.","page":"1D Path","title":"Graph Signal Processing via GHWT, eGHWT, etc.","text":"","category":"section"},{"location":"examples/P64/","page":"1D Path","title":"1D Path","text":"## analyze the signal via GHWT\ndmatrix = ghwt_analysis!(G, GP = GP)\n\n## Haar\nBS_haar = bs_haar(GP)\ndvec_haar = dmatrix2dvec(dmatrix, GP, BS_haar)\n\n## Walsh\nBS_walsh = bs_walsh(GP)\ndvec_walsh = dmatrix2dvec(dmatrix, GP, BS_walsh)\n\n## GHWT_c2f\ndvec_c2f, BS_c2f = ghwt_c2f_bestbasis(dmatrix, GP)\n\n## GHWT_f2c\ndvec_f2c, BS_f2c = ghwt_f2c_bestbasis(dmatrix, GP)\n\n## eGHWT\ndvec_eghwt, BS_eghwt = ghwt_tf_bestbasis(dmatrix, GP)\nnothing # hide","category":"page"},{"location":"examples/P64/","page":"1D Path","title":"1D Path","text":"We then find the top 10 basis vectors in each case.","category":"page"},{"location":"examples/P64/","page":"1D Path","title":"1D Path","text":"## Haar\nimportant_idx = sortperm(dvec_haar[:].^2; rev = true)\nhaar_top10 = zeros(N, 10)\nfor i in 1:10\n    w = ghwt_synthesis(reshape(spike(important_idx[i], N), (N, 1)), GP, BS_haar)\n    haar_top10[:, i] = w[:]\nend\nwiggle(haar_top10; sc = 0.45)\np1 = title!(\"Top 10 Haar basis vectors\")\n\n## Walsh\nimportant_idx = sortperm(dvec_walsh[:].^2; rev = true)\nwalsh_top10 = zeros(N, 10)\nfor i in 1:10\n    w = ghwt_synthesis(reshape(spike(important_idx[i], N), (N, 1)), GP, BS_walsh)\n    walsh_top10[:, i] = w[:]\nend\nwiggle(walsh_top10; sc = 0.45)\np2 = title!(\"Top 10 Walsh basis vectors\")\n\n## GHWT_c2f\nimportant_idx = sortperm(dvec_c2f[:].^2; rev = true)\nghwt_c2f_top10 = zeros(N, 10)\nfor i in 1:10\n    w = ghwt_synthesis(reshape(spike(important_idx[i], N), (N, 1)), GP, BS_c2f)\n    ghwt_c2f_top10[:, i] = w[:]\nend\nwiggle(ghwt_c2f_top10; sc = 0.45)\np3 = title!(\"Top 10 GHWT c2f best basis vectors\")\n\n## GHWT_f2c\nimportant_idx = sortperm(dvec_f2c[:].^2; rev = true)\nghwt_f2c_top10 = zeros(N, 10)\nfor i in 1:10\n    w = ghwt_synthesis(reshape(spike(important_idx[i], N), (N, 1)), GP, BS_f2c)\n    ghwt_f2c_top10[:, i] = w[:]\nend\nwiggle(ghwt_f2c_top10; sc = 0.45)\np4 = title!(\"Top 10 GHWT f2c best basis vectors\")\n\n## eGHWT\nimportant_idx = sortperm(dvec_eghwt[:].^2; rev = true)\neghwt_top10 = zeros(N, 10)\nfor i in 1:10\n    w = ghwt_synthesis(reshape(spike(important_idx[i], N), (N, 1)), GP, BS_eghwt)\n    eghwt_top10[:, i] = w[:]\nend\nwiggle(eghwt_top10; sc = 0.45)\np5 = title!(\"Top 10 eGHWT best basis vectors\")\n\n# display the top 10 basis vectors\nplot(p1, p2, p3, p4, p5, layout = Plots.grid(5, 1), size = (815, 1500))\nxticks!([1; 8:8:64], vcat(string(\"1\"), [string(k) for k in 8:8:64])) # hide\nyticks!([0; 1:10], vcat(string(\"\"), [string(k) for k in 1:10])) # hide\nplot!(left_margin = 5mm) # hide","category":"page"},{"location":"examples/P64/#Graph-Signal-Processing-via-the-NGWP-dictionaries","page":"1D Path","title":"Graph Signal Processing via the NGWP dictionaries","text":"","category":"section"},{"location":"examples/P64/","page":"1D Path","title":"1D Path","text":"To perform the NGWP transforms, we set up the dual graph G^star (which is also P_64).","category":"page"},{"location":"examples/P64/","page":"1D Path","title":"1D Path","text":"# build the dual graph object\nGstar = GraphSig(W)\n\n# perform recursive bipartitioning of Gstar by the Fiedler vectors of Lrw\nGstarP = partition_tree_fiedler(Gstar; swapRegion = false)\n\n# perform the pair-clustering algorithm to recursively bipartition G\nGP_pc = pairclustering(ùöΩ, GstarP)  # for PC-NGWP\nnothing # hide","category":"page"},{"location":"examples/P64/","page":"1D Path","title":"1D Path","text":"Now, let us construct the three NGWP dictionaries (i.e., the VM-NGWP, the PC-NGWP, and the LP-NGWP) and use them to analyze the signal, respectively.","category":"page"},{"location":"examples/P64/","page":"1D Path","title":"1D Path","text":"VM_NGWP = vm_ngwp(ùöΩ, GstarP)\nPC_NGWP = pc_ngwp(ùöΩ, GstarP, GP_pc)\nLP_NGWP = lp_ngwp(ùöΩ, W, GstarP; œµ = 0.3)  # relative action region bandwidth œµ\n\n# NGWP analysis, i.e., get the expansion coefficient matrix and apply the best\n# basis algorithm.\ndmatrix_VM = ngwp_analysis(G, VM_NGWP)\ndvec_vm_ngwp, BS_vm_ngwp = ngwp_bestbasis(dmatrix_VM, GstarP)\ndmatrix_PC = ngwp_analysis(G, PC_NGWP)\ndvec_pc_ngwp, BS_pc_ngwp = ngwp_bestbasis(dmatrix_PC, GstarP)\ndmatrix_LP = ngwp_analysis(G, LP_NGWP)\ndvec_lp_ngwp, BS_lp_ngwp = ngwp_bestbasis(dmatrix_LP, GstarP)\nnothing # hide","category":"page"},{"location":"examples/P64/","page":"1D Path","title":"1D Path","text":"Then, the top 10 NGWP basis vectors selected from each dictionary can be displayed as follows.","category":"page"},{"location":"examples/P64/","page":"1D Path","title":"1D Path","text":"important_idx = sortperm(dvec_vm_ngwp[:].^2; rev = true)\nwav_vm_top10 = zeros(N, 10)\nfor i in 1:10\n    dr, dc = BS_vm_ngwp.levlist[important_idx[i]]\n    wav_vm_top10[:, i] = VM_NGWP[dr, dc, :]\nend\nwiggle(wav_vm_top10; sc = 0.45)\np1 = title!(\"Top 10 VM-NGWP basis vectors\")\n\nimportant_idx = sortperm(dvec_pc_ngwp[:].^2; rev = true)\nwav_pc_top10 = zeros(N, 10)\nfor i in 1:10\n    dr, dc = BS_pc_ngwp.levlist[important_idx[i]]\n    wav_pc_top10[:, i] = PC_NGWP[dr, dc, :]\nend\nwiggle(wav_pc_top10; sc = 0.45)\np2 = title!(\"Top 10 PC-NGWP basis vectors\")\n\nimportant_idx = sortperm(dvec_lp_ngwp[:].^2; rev = true)\nwav_lp_top10 = zeros(N, 10)\nfor i in 1:10\n    dr, dc = BS_lp_ngwp.levlist[important_idx[i]]\n    wav_lp_top10[:, i] = LP_NGWP[dr, dc, :]\nend\nwiggle(wav_lp_top10; sc = 0.45)\np3 = title!(\"Top 10 LP-NGWP basis vectors\")\n\nplot(p1, p2, p3, layout = Plots.grid(3, 1), size = (815, 900))\nxticks!([1; 8:8:64], vcat(string(\"1\"), [string(k) for k in 8:8:64])) # hide\nyticks!([0; 1:10], vcat(string(\"\"), [string(k) for k in 1:10])) # hide\nplot!(left_margin = 5mm) # hide","category":"page"},{"location":"functions/Utils/#Visualization","page":"Utils","title":"Visualization","text":"","category":"section"},{"location":"functions/Utils/#MultiscaleGraphSignalTransforms.gplot","page":"Utils","title":"MultiscaleGraphSignalTransforms.gplot","text":"gplot(A, xyz; plotp = true,\n      style = :auto, width = 2, color = :blue,\n      shape = :none, mwidth = 2, mcolor = color, malpha = 1.0,\n      mscolor = color, mswidth = 1, msalpha = 1.0,\n      grid::Bool = false, label = \"\", subplot = 1)\n\nGPLOT Plot graph, as in graph theory. GPLOT(A,xyz,...) plots the graph specified by the adjacency matrix A and the node coordinates xyz. GPLOT!(A,xyz,...) adds a plot to current one.\n\nInput Arguments\n\nA::SparseMatrixCSC{Float64,Int}: the adjacency matrix of a graph G\nxyz::Matrix{Float64}: The coordinates array, xyz, is an n-by-2 or n-by-3 matrix\n\nwith the position for node i in the i-th row, xyz[i,:] = [x[i] y[i]] or xyz[i,:] = [x[i] y[i] z[i]].\n\nplotp::Bool: if the plot is made (default) or return the X, Y, Z arrays\nstyle::Symbol: of line; choose from Symbol[:auto,:solid,:dash,:dot,:dashdot] (default: :auto)\nwidth::Number: of line in pixels (default: 2; fraction, e.g., 0.5 is allowed)\ncolor::Symbol: of line; choose from Symbol[:white,:blue,:red,:green,...] (default: :blue)\nshape::Symbol: choose from Symbol[:none,:auto,:circle,:rect,:star5,:diamond,                                     :hexagon,:cross,:xcross,:utriangle,                                     :dtriangle,:pentagon,:heptagon,:octagon,                                     :star4,:star6,:star7,:star8,:vline,:hline] (default: :none)\nmwidth::Number: marker size (or radius) in pixels (default: 2)\nmcolor::Symbol: of marker (default: the same as line color)\nmalpha::Float64: opacity of marker interior; choose from [0,1] (default: 1.0)\nmswidth::Number: marker stroke size (width) in pixels (default: 1)\nmscolor::Symbol: of marker stroke (default: the same as line color)\nmsalpha::Float64: opacity of marker stroke; choose from [0,1] (default: 1.0)\ngrid::Bool: a flag to show grid lines (default: false)\nlabel::String: a string for legend (default: \"\")\nsubplot::Int: subplot index (default: 1)\n\nOutput Arguments\n\nX::Matrix{Float64}: Nan-punctuated X coordinate vector\nY::Matrix{Float64}: Nan-punctuated Y coordinate vector\nZ::Matrix{Float64}: Nan-punctuated Z coordinate vector\n\n(X,Y)= GPLOT(A,xyz,plotp=false,...) or (X,Y,Z) = GPLOT(A,xyz,plotp=false,...) return the NaN-punctuated vectors X and Y or X, Y and Z without actually generating a plot. These vectors can be used to generate the plot at a later time with PLOT or PLOT3D if desired.\n\nA backward-compatible elaboration of Mathworks's gplot that uses 3D data (if available) when the plot is rotated. Robert Piche, Tampere Univ. of Tech., 2005\n\nTranslated into julia by Naoki Saito, Dec. 21, 2016. Note that we should still consider the keywords organized as function gplot(A,xyz,kw...)\n\nNicholas Hausch edits: Must install Plots package For 3D rotation, use plotlyjs() backend\n\nRevised by Naoki Saito, Feb. 17, 2017 Revised by Naoki Saito, Oct. 13, 2017 Revised by Haotian Li, Jul. 25, 2018 Revised by Haotian Li and Naoki Saito for Julia v0.7/1.0, Sep. 21, 2018 Instead of plot(...), we decided to use Plots.plot(...) in order to avoid     the function name ambiguity; this is a safer approach. Revised by Naoki Saito, Oct. 22, 2018\n\n\n\n\n\n","category":"function"},{"location":"functions/Utils/#MultiscaleGraphSignalTransforms.scatter_gplot","page":"Utils","title":"MultiscaleGraphSignalTransforms.scatter_gplot","text":"scatter_gplot(X; marker = nothing, ms = 4, plotOrder = :normal, c = :viridis, subplot = 1)\n\nSCATTER_GPLOT generates a scatter plot figure, which is for quick viewing of a graph signal. SCATTER_GPLOT!(X; ...) adds a plot to current one.\n\nInput Arguments\n\nX::Matrix{Float64}: points locations, can be 2-dim or 3-dim.\nmarker::Array{Float64}: default is nothing. Present different colors given   different signal value at each node.\nms::Array{Float64}: default is 4. Present different node sizes given   different signal value at each node.\nshape::Symbol: default is :none. Shape of the markers.\nmswidth::Number: default is 0. Width of the marker stroke border.\nmsalpha::Number: default is nothing. The opacity for the marker stroke.\nplotOrder::Symbol: default is :normal. Optional choices :s2l or :l2s, i.e.,   plots from the smallest value of marker to the largest value or the other way around,   or :propabs, ms is automatically set to be proportional to the absolute value   of the marker values.\nc::Symbol: default is :viridis. Colors of the markers.\nsubgplot::Int: default is 1. The subplot index.\n\n\n\n\n\n","category":"function"},{"location":"functions/Utils/#MultiscaleGraphSignalTransforms.GraphSig_Plot","page":"Utils","title":"MultiscaleGraphSignalTransforms.GraphSig_Plot","text":"GraphSig_Plot(G::GraphSig; symmetric::Bool = false,\n  markersize::Float64 = 2.,\n  markercolor::Symbol = :balance,\n  markershape::Symbol = :circle,\n  markerstrokewidth::Float64 = 1.0,\n  markerstrokealpha::Float64 = 1.0,\n  markervaluevaries::Bool = true,\n  linewidth::Float64 = 1.,\n  linecolor::Symbol = :blue,\n  linestyle::Symbol = :solid,\n  clim::Tuple{Float64,Float64} = (0., 0.),\n  notitle::Bool = false, nocolorbar::Bool = false, nolegend::Bool = true,\n  stemplot::Bool = false, sortnodes::Symbol = :normal)\n\nDisplay a plot of the data in a GraphSig object\n\nInput Argument\n\nG::GraphSig:        an input GraphSig object\nsymmetric           symmetrize the colorbar\nmarkersize          the size of the nodes\nmarkercolor         markercolor scheme\nmarkershape         shape of marker\nmarkerstrokewidth   width of marker stroke\nmarkerstrokealpha   capacity of marker stroke\nmarkervaluevaries   if the marker color depends on the signal value\nlinewidth           the width of the lines in gplot\nlinecolor           the color of the lines (1D) / graph edges (2D & 3D)\nlinestyle:          the style of line\nnotitle             display a title\nnocolorbar          display a colorbar\nnolegend            display a legend\nstemplot            use a stem plot\nclim                specify the dynamic display range\nsortnodes           plot the signal values from smallest to largest in magnitude\n\n\n\n\n\n","category":"function"},{"location":"functions/Utils/#Best-Basis-Related","page":"Utils","title":"Best Basis Related","text":"","category":"section"},{"location":"functions/Utils/#MultiscaleGraphSignalTransforms.cost_functional","page":"Utils","title":"MultiscaleGraphSignalTransforms.cost_functional","text":"costfun = cost_functional(cfspec::Any)\n\nDetermine the cost functional to be used by the best-basis algorithm.\n\nInput Argument\n\ncfspec::Any: the specification for the cost functional\n\nOutput Argument\n\ncostfun::Function: the cost functional (as a function_handle)\n\n\n\n\n\n","category":"function"},{"location":"functions/Utils/#MultiscaleGraphSignalTransforms.dmatrix_flatten","page":"Utils","title":"MultiscaleGraphSignalTransforms.dmatrix_flatten","text":"dmatrix_flatten(dmatrix::Array{Float64,3}, flatten::Any)\n\nFlatten dmatrix using the method specified by the string \"flatten\"\n\nInput Arguments\n\ndmatrix::Array{Float64,3}: the matrix of expansion coefficients; after this function is called, it becomes the size of (~, ~, 1).\nflatten::Any: the method for flattening dmatrix (see the code in details)\n\n\n\n\n\n","category":"function"},{"location":"functions/Utils/#MultiscaleGraphSignalTransforms.dmatrix_ldb_flatten","page":"Utils","title":"MultiscaleGraphSignalTransforms.dmatrix_ldb_flatten","text":"function dmatrix_ldb_flatten(dmatrix::Array{Float64,3}...; dm::Symbol = :KLdivergence)\n\nFlatten dmatrices using the LDB method; after this function is called, it returns a matrix of size (~, ~, 1).\n\nInput Arguments\n\ndmatrix::Array{Float64,3}: the matrix of LDB expansion coefficients in one class.\ndm::Symbol: discriminant measure. Options: :KLdivergence (default),   :Jdivergence, :l1, :l2, and :Hellinger.\n\nExample Usage:\n\ndmatrix_ldb_flatten(dmatrix1, dmatrix2, dmatrix3), each argument is the expansion coefficient matrix of a class of signals. It uses the default discriminant measure KL divergence to flatten these matrices. In other words, it flattens these expansion coefficent matrices by computing and summing \"statistical distances\" among them.\n\n\n\n\n\n","category":"function"},{"location":"examples/Sunflower/#Visualization-of-the-Sunflower-Graph","page":"Sunflower Graph","title":"Visualization of the Sunflower Graph","text":"","category":"section"},{"location":"examples/Sunflower/#MultiscaleGraphSignalTransforms.SunFlowerGraph","page":"Sunflower Graph","title":"MultiscaleGraphSignalTransforms.SunFlowerGraph","text":"SunFlowerGraph(; N = 400)\n\nSUNFLOWERGRAPH construct a simple weighted sunflower graph with N vertices. Edge weights are the reciprocal of Euclidean distances.\n\nInput Arguments\n\nN::Int64: default is 400, the number of vertices. Requires N > 26.\n\nOutput Argument\n\nG::SimpleWeightedGraph{Int64,Float64}: a simple weighted graph of the sunflower.\nL::Matrix{Float64}: the weighted unnormalized graph Laplacian matrix.\nX::Matrix{Float64}: a matrix whose i-th row represent the 2D coordinates of the i-th node.\n\n\n\n\n\n","category":"function"},{"location":"examples/Sunflower/","page":"Sunflower Graph","title":"Sunflower Graph","text":"Let us see how to visualize the sunflower graph by gplot() and scatter_gplot().","category":"page"},{"location":"examples/Sunflower/","page":"Sunflower Graph","title":"Sunflower Graph","text":"using MultiscaleGraphSignalTransforms, Graphs, Plots\n\n# construct the sunflower graph\nG, L, X = SunFlowerGraph(); N = nv(G)\n\n# display the sunflower graph (node radii vary for visualization purpose)\ngplot(1.0 * adjacency_matrix(G), X; width = 1)\nscatter_gplot!(X; c = :red, ms = LinRange(1, 9, N))\nplot!(frame = :none, size = (815, 500)) # hide","category":"page"},{"location":"examples/Sunflower/","page":"Sunflower Graph","title":"Sunflower Graph","text":"One can also represent a signal on the graph by colors. For example,","category":"page"},{"location":"examples/Sunflower/","page":"Sunflower Graph","title":"Sunflower Graph","text":"f = zeros(N)\nf[1:200] .= 1\nf[301:N] .= -1\n\n# display the graph signal\ngplot(1.0 * adjacency_matrix(G), X; width = 1)\nscatter_gplot!(X; marker = f, ms = LinRange(1, 9, N))\nplot!(frame = :none, size = (815, 500)) # hide","category":"page"},{"location":"functions/eGHWT/#extended-Generalized-Haar-Walsh-Transform","page":"extended Generalized Haar-Walsh Transform","title":"extended Generalized Haar-Walsh Transform","text":"","category":"section"},{"location":"functions/eGHWT/","page":"extended Generalized Haar-Walsh Transform","title":"extended Generalized Haar-Walsh Transform","text":"Pages = [\"eGHWT.md\"]","category":"page"},{"location":"functions/eGHWT/#MultiscaleGraphSignalTransforms.GHWT_tf_1d.ghwt_tf_bestbasis-Tuple{Array{Float64, 3}, GraphPart}","page":"extended Generalized Haar-Walsh Transform","title":"MultiscaleGraphSignalTransforms.GHWT_tf_1d.ghwt_tf_bestbasis","text":"(dvec, BS) = ghwttfbestbasis(dmatrix::Array{Float64,3}, GP::GraphPart; cfspec::Float64 = 1.0, flatten::Any = 1.0)\n\nImplementation of time-frequency adapted GHWT method = eGHWT. Modified from the algorithm in the paper: \"A Fast Algorithm for Adapted Time Frequency Tilings\" by Christoph M. Thiele and Lars F. Villemoes.\n\nInput Arguments\n\ndmatrix::Array{Float64,3}: the matrix of expansion coefficients\nGP::GraphPart: an input GraphPart object\ncfspec::Any: the specification of cost functional to be used (default: 1.0, i.e., 1-norm)\nflatten::Any: the method for flattening vector-valued data to scalar-valued data (default: 1.0, i.e., 1-norm)\n\nOutput Arguments\n\ndvec::Matrix{Float64}: the vector of expansion coefficients corresponding to the eGHWT best basis\nBS::BasisSpec: a BasisSpec object which specifies the eGHWT best basis\n\nCopyright 2018 The Regents of the University of California\n\nImplemented by Yiqun Shao (Adviser: Dr. Naoki Saito)\n\n\n\n\n\n","category":"method"},{"location":"functions/eGHWT/#MultiscaleGraphSignalTransforms.GHWT_tf_1d.tf_basisrecover_new-Tuple{Array{Dict{Tuple{Int64, Int64}, Bool}}, Array{Dict{Tuple{Int64, Int64}, Bool}}}","page":"extended Generalized Haar-Walsh Transform","title":"MultiscaleGraphSignalTransforms.GHWT_tf_1d.tf_basisrecover_new","text":"tag_tf_b_new = tf_basisrecover_new(tag_tf_b::Array{Dict{Tuple{Int,Int},Bool}},tag_tf_f::Array{Dict{Tuple{Int,Int},Bool}})\n\nOne backward iteration of time-frequency adapted GHWT method to recover the best-basis from the `tag_tf`s recorded.\n\nInput Arguments\n\ntag_tf_b: The dictionary recording the time-or-frequency information on some iteration 'i' in the main algorithm\ntag_tf_f: The dictionary recording the time-or-frequency information on some iteration 'i+1' in the main algorithm\n\nOutput Arguments\n\ntag_tf_b_new: The updated 'tagtfb'. Eventually the 'tag_tf' on iteration 1 will represent the selected best-basis\n\nCopyright 2018 The Regents of the University of California\n\nImplemented by Yiqun Shao (Adviser: Dr. Naoki Saito)\n\n\n\n\n\n","category":"method"},{"location":"functions/eGHWT/#MultiscaleGraphSignalTransforms.GHWT_tf_1d.tf_core_new-Tuple{Vector{Dict{Tuple{Int64, Int64}, Float64}}}","page":"extended Generalized Haar-Walsh Transform","title":"MultiscaleGraphSignalTransforms.GHWT_tf_1d.tf_core_new","text":"coeffdictnew,tagtf = tfcorenew(coeffdict::Array{Dict{Tuple{Int,Int},Float64},1})\n\nOne forward iteration of time-frequency adapted GHWT method. For each entry in coeffdict_new, we compare two (or one) entries in 'coeffdict' on time-direction and two (or one) entries in 'coeffdict' on frequency-direction. Those two groups reprensent the same subspace. We compare the cost-functional value of them and choose the smaller one as a new entry in 'coeffdict_new'.\n\nInput Arguments\n\ncoeffdict: The entries of which reprensents the cost functional value of some basis-vectors' coefficients.\n\nOutput Arguments\n\ncoeffdict_new: The entries of which represents the cost functional value of some basis-vectors' coefficients\ntag_tf: Indicating whether the time-direction (0) or frequency direction (1) was chosen for each entry in coeffdict_new.\n\nCopyright 2018 The Regents of the University of California\n\nImplemented by Yiqun Shao (Adviser: Dr. Naoki Saito)\n\n\n\n\n\n","category":"method"},{"location":"functions/eGHWT/#MultiscaleGraphSignalTransforms.GHWT_tf_1d.tf_init-Tuple{Matrix{Float64}, GraphPart}","page":"extended Generalized Haar-Walsh Transform","title":"MultiscaleGraphSignalTransforms.GHWT_tf_1d.tf_init","text":"coeffdict = tf_init(dmatrix::Matrix{Float64},GP::GraphPart)\n\nStore the expanding coeffcients from matrix into a list of dictionary (inbuilt hashmap in Julia)\n\nInput Arguments\n\ndmatrix: The expanding GHWT coefficients of all levels corresponding to input GP\nGP::GraphPart: an input GraphPart object\n\nOutput Arguments\n\ncoeffdict: The expanding GHWT coeffcients stored in a list of \"dictionary\" (inbuilt hashmap in Julia),\ncoeffdict: The entry coeffdict[j][(k,l)] corresponds to the coefficient of basis-vector on level j with region k and tag l.\n\nCopyright 2018 The Regents of the University of California\n\nImplemented by Yiqun Shao (Adviser: Dr. Naoki Saito)\n\n\n\n\n\n","category":"method"},{"location":"functions/eGHWT/#MultiscaleGraphSignalTransforms.GHWT_tf_2d.ghwt_tf_bestbasis_2d-Tuple{Matrix{Float64}, GraphPart, GraphPart}","page":"extended Generalized Haar-Walsh Transform","title":"MultiscaleGraphSignalTransforms.GHWT_tf_2d.ghwt_tf_bestbasis_2d","text":"Bbasis, infovec = ghwt_tf_bestbasis_2d(dmatrix::Matrix{Float64},GProws::GraphPart,GPcols::GraphPart)\n\nImplementation of 2d time-frequency adapted GHWT method. Modified from the idea in paper \"Image compression with adaptive Haar-Walsh tilings\" by Maj Lindberg and Lars F. Villemoes.\n\nInput Arguments\n\ndmatrix: The ghwt expanding coefficients of matrix on all levels contatenated in a 2d matrix.\nGProws: Corresponding to the affinity matrix on rows.\nGPcols: Corresponding to the affinity matrix on cols.\n\nOutput Arguments\n\nBbasis: The coefficients of the best-basis.\ninfovec: [infovec[i,1],infovec[i,2]] is the location of Bbasis[i] in dmatrix.\n\nCopyright 2018 The Regents of the University of California\n\nImplemented by Yiqun Shao (Adviser: Dr. Naoki Saito)\n\n\n\n\n\n","category":"method"},{"location":"functions/eGHWT/#MultiscaleGraphSignalTransforms.GHWT_tf_2d.ghwt_tf_init_2d-Tuple{Matrix{Float64}, GraphPart, GraphPart}","page":"extended Generalized Haar-Walsh Transform","title":"MultiscaleGraphSignalTransforms.GHWT_tf_2d.ghwt_tf_init_2d","text":"dmatrix = ghwt_tf_init_2d(matrix::Matrix{Float64}, GProws::GraphPart, GPcols::GraphPart)\n\nPartition matrix first to get GProws and GPcols. Then expand matrix\nin two directions to get dmatrix\n\nInput Arguments\n\nmatrix::Matrix{Float64}: an input matrix\nGProws::GraphPart: partitioning using rows as samples\nGPcols::GraphPart: partitioning using cols as samples\n\nOutput Argument\n\ndmatrix::matrix{Float64}: expansion coefficients of matrix\n\n\n\n\n\n","category":"method"},{"location":"functions/eGHWT/#MultiscaleGraphSignalTransforms.GHWT_tf_2d.ghwt_tf_init_2d-Tuple{Matrix{Float64}}","page":"extended Generalized Haar-Walsh Transform","title":"MultiscaleGraphSignalTransforms.GHWT_tf_2d.ghwt_tf_init_2d","text":"dmatrix, GProws, GPcols = ghwt_tf_init_2d(matrix::Matrix{Float64})\n\nPartition matrix first to get GProws and GPcols. Then expand matrix\nin two directions to get dmatrix\n\nInput Arguments\n\nmatrix::Matrix{Float64}: an input matrix\n\nOutput Argument\n\nGProws::GraphPart: partitioning using rows as samples\nGPcols::GraphPart: partitioning using cols as samples\ndmatrix::matrix{Float64}: expansion coefficients of matrix\n\n\n\n\n\n","category":"method"},{"location":"functions/eGHWT/#MultiscaleGraphSignalTransforms.GHWT_tf_2d.ghwt_tf_synthesis_2d-Tuple{Vector{Float64}, Matrix{Int64}, GraphPart, GraphPart}","page":"extended Generalized Haar-Walsh Transform","title":"MultiscaleGraphSignalTransforms.GHWT_tf_2d.ghwt_tf_synthesis_2d","text":"matrix = ghwt_tf_synthesis_2d(dmatrix::Matrix{Float64}, GProws::GraphPart, GPcols::GraphPart)\n\nSynthesis the matrix from the coefficients of selected basis vectors.\n\nInput Arguments\n\ndmatrix: Only selected basis vectors are nonzero with expanding coeffcients.\nGProws: Corresponding to the affinity matrix on rows.\nGPcols: Corresponding to the affinity matrix on cols.\n\nOutput Arguments\n\nmatrix: Synthesized matrix\n\nCopyright 2018 The Regents of the University of California\n\nImplemented by Yiqun Shao (Adviser: Dr. Naoki Saito)\n\n\n\n\n\n","category":"method"},{"location":"functions/eGHWT/#MultiscaleGraphSignalTransforms.GHWT_tf_2d.ghwt_tf_synthesis_2d_core!-Tuple{Array{Float64, 3}, Matrix{Int64}, Matrix{Int64}}","page":"extended Generalized Haar-Walsh Transform","title":"MultiscaleGraphSignalTransforms.GHWT_tf_2d.ghwt_tf_synthesis_2d_core!","text":"ghwt_tf_synthesis_2d_core!(dmatrix::Array{Float64,3},tag::Array{Int,2},rs::Array{Int,2})\n\nCore function of ghwttfsynthesis_2d. Synthesize on column direction\n\nInput Arguments\n\ndmatrix: Same size as dmatrix, but only selected basis vectors are nonzero with expanding coeffcients.\ntag: Tag information in GP.\nrs: Rs information in GP.\n\nOutput Arguments\n\ndmatrix: Synthesized on column direction.\n\nCopyright 2018 The Regents of the University of California\n\nImplemented by Yiqun Shao (Adviser: Dr. Naoki Saito)\n\n\n\n\n\n","category":"method"},{"location":"functions/eGHWT/#MultiscaleGraphSignalTransforms.GHWT_tf_2d.tf2d_init-Tuple{Matrix{Int64}, Matrix{Int64}}","page":"extended Generalized Haar-Walsh Transform","title":"MultiscaleGraphSignalTransforms.GHWT_tf_2d.tf2d_init","text":"tf2d_init(tag::Matrix{Int},tag_r::Matrix{Int})\n\nStoring the relation between the coefficient location in the 2D coefficients matrix of all levels with the (level, tag, region) information\n\nInput Arguments\n\ntag: The matrix of the tag information\ntag_r: The matrix of the region information\n\nOutput Arguments\n\ntag2ind: tag2ind[(j,k,l)] is the location of the column of coefficients on level j, region k and tag l\nind2tag: key and item of dicionary tag2ind interchanged\n\nCopyright 2018 The Regents of the University of California\n\nImplemented by Yiqun Shao (Adviser: Dr. Naoki Saito)\n\n\n\n\n\n","category":"method"},{"location":"functions/eGHWT/#MultiscaleGraphSignalTransforms.GHWT_tf_2d.tf_core_2d_col-Tuple{Matrix{Float64}, Dict{Tuple{Int64, Int64, Int64}, Int64}, Dict{Int64, Tuple{Int64, Int64, Int64}}, Integer}","page":"extended Generalized Haar-Walsh Transform","title":"MultiscaleGraphSignalTransforms.GHWT_tf_2d.tf_core_2d_col","text":"dmatrix_new,tag2ind_new,ind2tag_new,tag_tf = tf_core_2d_col(dmatrix::Matrix{Float64},tag2ind::Dict{Tuple{Int,Int,Int},Int},ind2tag::Dict{Int,Tuple{Int,Int,Int}},jmax::Integer)\n\nOne forward iteration of 2-d time-frequency adapted ghwt on the column direction\n\nInput Arguments\n\ndmatrix: The cost-functional values of coeffcients\ntag2ind: tag2ind[(j,k,l)] is the location of the column of coefficients on level j, region k and tag l\nind2tag: key and item of dicionary tag2ind interchanged\n\nOutput Arguments\n\ndmatrix_new: The cost-functional values of coeffcients\ntag2ind_new: tag2ind_new[(j,k,l)] is the location of the column of coefficients on level j, region k and tag l\nind2tag_new: key and item of dicionary tag2ind interchanged\ntag_tf: recording the time-or-frequency information\n\nCopyright 2018 The Regents of the University of California\n\nImplemented by Yiqun Shao (Adviser: Dr. Naoki Saito)\n\n\n\n\n\n","category":"method"},{"location":"functions/eGHWT/#MultiscaleGraphSignalTransforms.GHWT_tf_2d.tf_core_2d_row-Tuple{Matrix{Float64}, Dict{Tuple{Int64, Int64, Int64}, Int64}, Dict{Int64, Tuple{Int64, Int64, Int64}}, Integer}","page":"extended Generalized Haar-Walsh Transform","title":"MultiscaleGraphSignalTransforms.GHWT_tf_2d.tf_core_2d_row","text":"dmatrix_new,tag2ind_new,ind2tag_new,tag_tf = tf_core_2d_row(dmatrix::Matrix{Float64},tag2ind::Dict{Tuple{Int,Int,Int},Int},ind2tag::Dict{Int,Tuple{Int,Int,Int}},jmax::Integer)\n\nAlmost the same as tfcore2dcol. But all the operations on matrix are row-wise. Due to the column-based matrix feature of Julia language. We are currently only using the tfcore2dcol here.\n\nInput Arguments\n\ndmatrix: The cost-functional values of coeffcients\ntag2ind: tag2ind[(j,k,l)] is the location of the column of coefficients on level j, region k and tag l\nind2tag: key and item of dicionary tag2ind interchanged\n\nOutput Arguments\n\ndmatrix_new: The cost-functional values of coeffcients\ntag2ind_new: tag2ind_new[(j,k,l)] is the location of the row of coefficients on level j, region k and tag l\nind2tag_new: key and item of dicionary tag2ind interchanged\ntag_tf: recording the time-or-frequency information\n\nCopyright 2018 The Regents of the University of California\n\nImplemented by Yiqun Shao (Adviser: Dr. Naoki Saito)\n\n\n\n\n\n","category":"method"},{"location":"examples/Grid7x3/#Metrics-of-Graph-Laplacian-Eigenvectors-on-P_7-\\times-P_3","page":"2D Lattice","title":"Metrics of Graph Laplacian Eigenvectors on P_7 times P_3","text":"","category":"section"},{"location":"examples/Grid7x3/#Set-up","page":"2D Lattice","title":"Set up","text":"","category":"section"},{"location":"examples/Grid7x3/","page":"2D Lattice","title":"2D Lattice","text":"using MultiscaleGraphSignalTransforms, Graphs, MultivariateStats\nusing Plots, LaTeXStrings, LinearAlgebra\n\n# compute the graph related quantities\nNx, Ny = 7, 3\nG = Graphs.SimpleGraphs.grid([Nx, Ny])\nN = nv(G)\nL = Matrix(laplacian_matrix(G))\nQ = incidence_matrix(G; oriented = true)\nùõå, ùöΩ = eigen(L)\nùöΩ = ùöΩ .* sign.(ùöΩ[1, :])'  # sign of DCT\n‚àáùöΩ = Q' * ùöΩ\nW = 1.0 * adjacency_matrix(G)\n\n# manually set up the mapping between 1D ordering and 2D ordering\ngrid2eig_ind = [1,2,3,6,8,12,15,4,5,7,9,13,16,18,10,11,14,17,19,20,21];\neig2grid_ind = sortperm(grid2eig_ind);\neig2dct = Array{Int64,3}(undef, Nx, Ny, 2);\nfor i = 1:Nx; for j = 1:Ny; eig2dct[i,j,1] = i-1; eig2dct[i,j,2] = j-1; end; end\neig2dct = reshape(eig2dct, (N, 2)); eig2dct = eig2dct[eig2grid_ind, :];\nnothing # hide","category":"page"},{"location":"examples/Grid7x3/","page":"2D Lattice","title":"2D Lattice","text":"Let us see the comparison between 1D ordering vs. 2D ordering of the eigenvectors.","category":"page"},{"location":"examples/Grid7x3/","page":"2D Lattice","title":"2D Lattice","text":"## 1D ordering: non-decreasing eigenvalue ordering\nplot(layout = Plots.grid(3, 7))\nfor i in 1:N\n    heatmap!(reshape(ùöΩ[:, i], (Nx, Ny))', c = :viridis, cbar = false,\n                clims = (-0.4,0.4), frame = :none, ratio = 1, ylim = [0, Ny + 1],\n                title = latexstring(\"\\\\phi_{\", i-1, \"}\"), titlefont = 12,\n                subplot = i)\nend\nplot!(size = (815, 350)) # hide","category":"page"},{"location":"examples/Grid7x3/","page":"2D Lattice","title":"2D Lattice","text":"## 2D ordering: natural frequency ordering\nplot(layout = Plots.grid(3, 7))\nfor i in 1:N\n    k = grid2eig_ind[i]\n    heatmap!(reshape(ùöΩ[:,k], (Nx, Ny))', c = :viridis, cbar = false,\n                clims = (-0.4,0.4), frame = :none, ratio = 1, ylim = [0, Ny + 1],\n                title = latexstring(\"\\\\varphi_{\", string(eig2dct[k,1]),\n                \",\", string(eig2dct[k,2]), \"}\"), titlefont = 12, subplot = i)\nend\nplot!(size = (815, 350)) # hide","category":"page"},{"location":"examples/Grid7x3/","page":"2D Lattice","title":"2D Lattice","text":"What we really want to do is to organize those eigenvectors based on their natural frequencies or their behaviors instead of their eigenvalues. To do that, we utilize the metrics discussed in the paper as follows. But first, we create a custom plotting function for later use.","category":"page"},{"location":"examples/Grid7x3/","page":"2D Lattice","title":"2D Lattice","text":"function grid7x3_mds_heatmaps(E, ùöΩ; Nx = 7, Ny = 3, annotate_ind = 1:N, plotOrder = 1:N)\n    # set up all heatmap plots' positions\n    max_x = maximum(E[1, :]); min_x = minimum(E[1, :])\n    width_x = max_x - min_x\n    max_y = maximum(E[2, :]); min_y = minimum(E[2, :])\n    width_y = max_y - min_y\n    dx = 0.005 * width_x; dy = dx;\n    xej = zeros(Nx, N); yej=zeros(Ny, N);\n    a = 5.0; b = 7.0;\n    for k = 1:N\n        xej[:,k] = LinRange(E[1,k] - Ny * a * dx, E[1, k] + Ny * a * dx, Nx)\n        yej[:,k] = LinRange(E[2,k] - a * dy, E[2, k] + a * dy, Ny)\n    end\n\n    plot()\n    for k in plotOrder\n        if k in annotate_ind\n            heatmap!(xej[:, k], yej[:, k], reshape(ùöΩ[:, k], (Nx, Ny))', c = :viridis,\n                     colorbar = false, ratio = 1, annotations = (xej[4, k],\n                     yej[3, k] + b*dy, text(latexstring(\"\\\\varphi_{\",\n                     string(eig2dct[k, 1]), \",\", string(eig2dct[k, 2]), \"}\"), 10)))\n        else\n            heatmap!(xej[:, k], yej[:, k], reshape(ùöΩ[:, k], (Nx, Ny))', c = :viridis,\n                     colorbar = false, ratio = 1)\n        end\n    end\n    plt = plot!(xlim = [min_x - 0.12 * width_x, max_x + 0.12 * width_x],\n                ylim = [min_y - 0.16 * width_y, max_y + 0.16 * width_y],\n                grid = false, clims = (-0.4, 0.4),\n                xlab = \"X‚ÇÅ\", ylab = \"X‚ÇÇ\")\n    return plt\nend\nnothing # hide","category":"page"},{"location":"examples/Grid7x3/#ROT-distance","page":"2D Lattice","title":"ROT distance","text":"","category":"section"},{"location":"examples/Grid7x3/","page":"2D Lattice","title":"2D Lattice","text":"Before we measure the ROT distance between the eigenvectors, we convert them to probability mass functions by taking entrywise squares. After we got the ROT distance matrix of the eigenvectors, we visualize the arrangement of the eigenvectors in mathbbR^2 via the classical MDS embedding.","category":"page"},{"location":"examples/Grid7x3/","page":"2D Lattice","title":"2D Lattice","text":"## ROT distance\nD = natural_eigdist(ùöΩ, ùõå, Q; Œ± = 0.5, input_format = :pmf1, distance = :ROT)\nE = transform(fit(MDS, D, maxoutdim=2, distances=true))\ngrid7x3_mds_heatmaps(E, ùöΩ)\nplot!(size = (815, 611)) # hide","category":"page"},{"location":"examples/Grid7x3/#DAG-distance","page":"2D Lattice","title":"DAG distance","text":"","category":"section"},{"location":"examples/Grid7x3/","page":"2D Lattice","title":"2D Lattice","text":"We organize the eigenvectors by the DAG distance.","category":"page"},{"location":"examples/Grid7x3/","page":"2D Lattice","title":"2D Lattice","text":"D = natural_eigdist(ùöΩ, ùõå, Q; distance = :DAG)\nE = transform(fit(MDS, D, maxoutdim=2, distances=true))\ngrid7x3_mds_heatmaps(E, ùöΩ)\nplot!(size = (815, 611)) # hide","category":"page"},{"location":"examples/Grid7x3/#TSD-distance","page":"2D Lattice","title":"TSD distance","text":"","category":"section"},{"location":"examples/Grid7x3/","page":"2D Lattice","title":"2D Lattice","text":"We organize the eigenvectors by the TSD distance with the parameter T = 01.","category":"page"},{"location":"examples/Grid7x3/","page":"2D Lattice","title":"2D Lattice","text":"D = natural_eigdist(ùöΩ, ùõå, Q; T = 0.1, distance = :TSD)  # T = 0.1\nE = transform(fit(MDS, D, maxoutdim=2, distances=true))\ngrid7x3_mds_heatmaps(E, ùöΩ)\nplot!(size = (815, 611)) # hide","category":"page"},{"location":"#MultiscaleGraphSignalTransforms.jl","page":"Home","title":"MultiscaleGraphSignalTransforms.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Haar-Walsh on R vs on Graph)","category":"page"},{"location":"","page":"Home","title":"Home","text":"MultiscaleGraphSignalTransforms.jl is a collection of tools for graph signal processing including HGLET, GHWT, eGHWT, NGWP, Lapped NGWP, and Lapped HGLET. Some of them were originally written in MATLAB by Jeff Irion, but we added more functionalities, e.g., eGHWT, NGWP, etc.","category":"page"},{"location":"#COPYRIGHT","page":"Home","title":"COPYRIGHT","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Copyright 2015-2021 The Regents of the University of California","category":"page"},{"location":"","page":"Home","title":"Home","text":"Implemented by Jeff Irion, Haotian Li, Naoki Saito, and Yiqun Shao","category":"page"},{"location":"#SETUP","page":"Home","title":"SETUP","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the MultiscaleGraphSignalTransforms.jl, run","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg; Pkg.add(\"MultiscaleGraphSignalTransforms\")\njulia> using MultiscaleGraphSignalTransforms","category":"page"},{"location":"#GETTING-STARTED","page":"Home","title":"GETTING STARTED","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently, you can run a set of very small tests via ] test MultiscaleGraphSignalTransforms; see the actual file test/runtest.jl for more details.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can also check out the examples we provided in the sidebar.","category":"page"},{"location":"#REFERENCES","page":"Home","title":"REFERENCES","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"J. Irion and N. Saito, Hierarchical graph Laplacian eigen transforms, Japan SIAM Letters, vol. 6, pp. 21-24, 2014.\nJ. Irion and N. Saito, The generalized Haar-Walsh transform, Proc. 2014 IEEE Statistical Signal Processing Workshop, pp. 488-491, 2014.\nJ. Irion and N. Saito, Applied and computational harmonic analysis on graphs and networks, Wavelets and Sparsity XVI, (M. Papadakis, V. K. Goyal, D. Van De Ville, eds.), Proc. SPIE 9597, Paper #95971F, Invited paper, 2015.\nJ. Irion, Multiscale Transforms for Signals on Graphs: Methods and Applications, Ph.D. dissertation, University of California, Davis, Dec. 2015.\nJ. Irion and N. Saito, Learning sparsity and structure of matrices with multiscale graph basis dictionaries, Proc. 2016 IEEE 26th International Workshop on Machine Learning for Signal Processing (MLSP), (A. Uncini, K. Diamantaras, F. A. N. Palmieri, and J. Larsen, eds.), 2016.\nJ. Irion and N. Saito, Efficient approximation and denoising of graph signals using the multiscale basis dictionaries, IEEE Transactions on Signal and Information Processing over Networks, Vol. 3, no. 3, pp. 607-616, 2017.\nY. Shao and N. Saito, The extended Generalized Haar-Walsh Transform and applications, Wavelets and Sparsity XVIII, (D. Van De Ville, M. Papadakis, and Y. M. Lu, eds.), Proc. SPIE 11138, Paper #111380C, 2019.\nY. Shao, The Extended Generalized Haar-Walsh Transform and Applications, Ph.D. dissertation, University of California, Davis, Sep. 2020.\nH. Li and N. Saito, Metrics of graph Laplacian eigenvectors, Wavelets and Sparsity XVIII, (D. Van De Ville, M. Papadakis, and Y. M. Lu, eds.), Proc. SPIE 11138, Paper #111381K, 2019.\nC. Alexander, H. Li and N. Saito, Natural graph wavelet packet dictionaries, J. Fourier Anal. Appl., vol. 27, Article #41, 2021.\nH. Li, Natural Graph Wavelet Dictionaries: Methods and Applications, Ph.D. dissertation, University of California, Davis, Jun. 2021.","category":"page"},{"location":"functions/GHWT/#Generalized-Haar-Walsh-Transform","page":"Generalized Haar-Walsh Transform","title":"Generalized Haar-Walsh Transform","text":"","category":"section"},{"location":"functions/GHWT/","page":"Generalized Haar-Walsh Transform","title":"Generalized Haar-Walsh Transform","text":"Pages = [\"GHWT.md\"]","category":"page"},{"location":"functions/GHWT/#MultiscaleGraphSignalTransforms.GHWT.GHWT_jkl-Tuple{GraphPart, Int64, Int64}","page":"Generalized Haar-Walsh Transform","title":"MultiscaleGraphSignalTransforms.GHWT.GHWT_jkl","text":"function GHWT_jkl(GP::GraphPart, drow::Int, dcol::Int; c2f::Bool = true)\n\nGenerate the (j,k,l) indices for the GHWT basis vector corresponding to the coefficient dmatrix(drow,dcol)\n\nInput Arguments\n\nGP: a GraphPart object\ndrow: the row of the expansion coefficient\ndcol: the column of the expansion coefficient\n\nOutput Argument\n\nj: the level index of the expansion coefficient\nk: the subregion index of the expansion coefficient\nl: the tag of the expansion coefficient\n\n\n\n\n\n","category":"method"},{"location":"functions/GHWT/#MultiscaleGraphSignalTransforms.GHWT.fine2coarse!-Tuple{GraphPart}","page":"Generalized Haar-Walsh Transform","title":"MultiscaleGraphSignalTransforms.GHWT.fine2coarse!","text":"(dmatrixf2c, IX) = fine2coarse!(GP::GraphPart;\ndmatrix::Array{Float64,3} = zeros(0, 0, 0),\ncoefp::Bool = false, indp::Bool = false)\n\nFill in the fine-to-coarse info (rs2f2c, tagf2c, and compinfof2c) in a GraphPart object.  Also, rearrange a matrix of expansion coefficients.\n\nInput Arguments\n\nGP::GraphPart: an input GraphPart object without fine-to-coarse info (rsf2c, tagf2c, compinfof2c); after this function, rsf2c, tagf2c, compinfof2c are filled. Note that rs, tag, compinfo are intact.\ndmatrix::Array{Float64,3}: a matrix of expansion coefficients in coarse-to-fine arrangement (default: null matrix)\ncoefp::Bool: a flag to return the rearranged f2c coefficients (default: false)\nindp::Bool: a flag to return the reordering index (default: false)\n\nOutput Arguments\n\ndmatrixf2c::Array{Float64,3}: a matrix of expansion coefficients in fine-to-coarse arrangement (if requested)\nIX::Vector{Unsigned}: the reordering index for all levels\n\n\n\n\n\n","category":"method"},{"location":"functions/GHWT/#MultiscaleGraphSignalTransforms.GHWT.ghwt_analysis!-Tuple{GraphSig}","page":"Generalized Haar-Walsh Transform","title":"MultiscaleGraphSignalTransforms.GHWT.ghwt_analysis!","text":"dmatrix = ghwt_analysis!(G::GraphSig, GP::GraphPart = nothing, c2f::Bool = true)\n\nFor a GraphSig object G, generate the matrix of GHWT expansion coefficients\n\nInput Arguments\n\nG::GraphSig: an input GraphSig object\nGP::GraphPart: an input GraphPart object (optional); after this function is run, GP's compinfo, tag, etc. are filled\n\nOutput Argument\n\ndmatrix::Array{Float64,3}: the 3D array of expansion coefficients (i.e., for each input signal vector, the matrix of coefficients; hence, for multiple input signals, the coefficients are organized as a 3D array)\n\n\n\n\n\n","category":"method"},{"location":"functions/GHWT/#MultiscaleGraphSignalTransforms.GHWT.ghwt_bestbasis-Tuple{Array{Float64, 3}, GraphPart}","page":"Generalized Haar-Walsh Transform","title":"MultiscaleGraphSignalTransforms.GHWT.ghwt_bestbasis","text":"(dvec, BS) = ghwt_bestbasis(dmatrix::Array{Float64,3}, GP::GraphPart; cfspec::Any, flatten::Any = 1.0)\n\nSelect the overall best basis among the c2f and f2c best bases\n\nInput Arguments\n\ndmatrix::Array{Float64,3}: the matrix of expansion coefficients\nGP::GraphPart: an input GraphPart object\ncfspec::Any: the specification of cost functional to be used (default: 1.0, i.e., 1-norm)\nflatten::Any: the method for flattening vector-valued data to scalar-valued data (default: 1.0, i.e., 1-norm)\n\nOutput Arguments\n\ndvec::Matrix{Float64}: the vector of expansion coefficients corresponding to the best basis\nBS::BasisSpec: a BasisSpec object which specifies the best basis\n\n\n\n\n\n","category":"method"},{"location":"functions/GHWT/#MultiscaleGraphSignalTransforms.GHWT.ghwt_c2f_bestbasis-Tuple{Array{Float64, 3}, GraphPart}","page":"Generalized Haar-Walsh Transform","title":"MultiscaleGraphSignalTransforms.GHWT.ghwt_c2f_bestbasis","text":"(dvecc2f, BSc2f) = ghwt_c2f_bestbasis(dmatrix::Array{Float64,3}, GP::GraphPart;\n                                      cfspec::Any = 1.0, flatten::Any = 1.0,\n                                      j_start::Int = 1, j_end::Int = size(dmatrix,2),\n                                      useParent::Bool = true)\n\nSelect the coarse-to-fine best basis from the matrix of GHWT expansion coefficients\n\nInput Arguments\n\ndmatrix::Array{Float64,3}: the matrix of expansion coefficients\nGP::GraphPart: an input GraphPart object\ncfspec::Any: the specification of cost functional to be used (default = 1.0, i.e., 1-norm)\nflatten::Any: the method for flattening vector-valued data to scalar-valued data (default = 1.0, i.e, 1-norm)\nuseParent::Bool: the flag to indicate if we update the selected best basis   subspace to the parent when parent and child have the same cost (default = true)\n\nOutput Arguments\n\ndvecc2f::Matrix{Float64}: the vector of expansion coefficients corresponding to the coarse-to-fine best basis\nBSc2f::BasisSpec: a BasisSpec object which specifies the coarse-to-fine best basis\n\n\n\n\n\n","category":"method"},{"location":"functions/GHWT/#MultiscaleGraphSignalTransforms.GHWT.ghwt_core!-Tuple{GraphPart, Array{Float64, 3}}","page":"Generalized Haar-Walsh Transform","title":"MultiscaleGraphSignalTransforms.GHWT.ghwt_core!","text":"ghwt_core!(GP::GraphPart, dmatrix::Array{Float64,3})\n\nperforms the forward GHWT transform, which generates expansion coefficients, tag, and compinfo.\n\nInput Arguments\n\nGP::GraphPart: a GraphPart object (with or without tag and compinfo data); note that tag and compinfo will be modified after this function is executed\ndmatrix::Array{Float64,3}: a matrix of expansion coefficients with only the last column filled in as the original input signal(s) f; after this function is executed, this matrix contains whole expansion coefficients of the input signal(s) relative to the GHWT dictionary\n\n\n\n\n\n","category":"method"},{"location":"functions/GHWT/#MultiscaleGraphSignalTransforms.GHWT.ghwt_core!-Tuple{GraphPart}","page":"Generalized Haar-Walsh Transform","title":"MultiscaleGraphSignalTransforms.GHWT.ghwt_core!","text":"ghwt_core!(GP::GraphPart)\n\nperforms the forward GHWT transform, which computes tag and compinfo of GP, but not the expansion coefficients.\n\nInput Arguments\n\nGP::GraphPart: a GraphPart object (with or without tag and compinfo data); note that tag and compinfo will be modified after this function is executed\n\n\n\n\n\n","category":"method"},{"location":"functions/GHWT/#MultiscaleGraphSignalTransforms.GHWT.ghwt_f2c_bestbasis-Tuple{Array{Float64, 3}, GraphPart}","page":"Generalized Haar-Walsh Transform","title":"MultiscaleGraphSignalTransforms.GHWT.ghwt_f2c_bestbasis","text":"(dvecf2c, BSf2c) = ghwt_f2c_bestbasis(dmatrix::Array{Float64,3}, GP::GraphPart;\n                                      cfspec::Any = 1.0, flatten::Any = 1.0,\n                                      j_start::Int = 1, j_end::Int = size(dmatrix,2),\n                                      useParent::Bool = true)\n\nSelect the fine-to-coarse best basis from the matrix of GHWT expansion coefficients\n\nInput Arguments\n\ndmatrix::Array{Float64,3}: the matrix of expansion coefficients\nGP::GraphPart: an input GraphPart object\ncfspec::Any: the specification of cost functional to be used (default: 1.0, i.e., 1-norm)\nflatten::Any: the method for flattening vector-valued data to scalar-valued data (default: 1.0, i.e., 1-norm)\nuseParent::Bool: the flag to indicate if we update the selected best basis   subspace to the parent when parent and child have the same cost (default = true)\n\nOutput Arguments\n\ndvecf2c::Matrix{Float64}: the vector of expansion coefficients corresponding to the fine-to-coarse best basis\nBSf2c::BasisSpec: a BasisSpec object which specifies the fine-to-coarse best basis\n\n\n\n\n\n","category":"method"},{"location":"functions/GHWT/#MultiscaleGraphSignalTransforms.GHWT.ghwt_synthesis-Tuple{Matrix{Float64}, GraphPart, BasisSpec, GraphSig}","page":"Generalized Haar-Walsh Transform","title":"MultiscaleGraphSignalTransforms.GHWT.ghwt_synthesis","text":"(f, GS) = ghwt_synthesis(dvec::Matrix{Float64}, GP::GraphPart, BS::BasisSpec, G::GraphSig)\n\nGiven a vector of GHWT expansion coefficients and info about the graph partitioning and the choice of basis, reconstruct the signal\n\nInput Arguments\n\ndvec::Matrix{Float64}: the expansion coefficients corresponding to the chosen basis\nGP::GraphPart: an input GraphPart object\nBS::BasisSpec: an input  BasisSpec object\nG::GraphSig: an input  GraphSig object\n\nOutput Arguments\n\nf::Matrix{Float64}: the reconstructed signal(s)\nGS::GraphSig: the reconstructed GraphSig object\n\n\n\n\n\n","category":"method"},{"location":"functions/GHWT/#MultiscaleGraphSignalTransforms.GHWT.ghwt_synthesis-Tuple{Matrix{Float64}, GraphPart, BasisSpec}","page":"Generalized Haar-Walsh Transform","title":"MultiscaleGraphSignalTransforms.GHWT.ghwt_synthesis","text":"f = ghwt_synthesis(dvec::Matrix{Float64}, GP::GraphPart, BS::BasisSpec)\n\nGiven a vector of GHWT expansion coefficients and info about the graph partitioning and the choice of basis, reconstruct the signal\n\nInput Arguments\n\ndvec::Matrix{Float64}: the expansion coefficients corresponding to the chosen basis\nGP::GraphPart: an input GraphPart object\nBS::BasisSpec: an input  BasisSpec object\n\nOutput Arguments\n\nf::Matrix{Float64}: the reconstructed signal(s)\n\n\n\n\n\n","category":"method"},{"location":"functions/GHWT/#MultiscaleGraphSignalTransforms.GHWT_2d.ghwt_2d_haar-Tuple{Matrix{Float64}, GraphPart, GraphPart}","page":"Generalized Haar-Walsh Transform","title":"MultiscaleGraphSignalTransforms.GHWT_2d.ghwt_2d_haar","text":"dvec = ghwt_2d_dmatrix2dvec(matrix::Array{Float64,2},BSrows::BasisSpec,BScols::BasisSpec)\n\nFor a matrix, equipped with row and column weight recursive partitionings and weight matrices, generate the (non-redundant) matrix of GHWT expansion coefficients, using the best basis algorithm to select best bases for the rows and columns\n\nInput Argument\n\nmatrix              the matrix to be analyzed\nGProws              the recursive partitioning on the rows\nGPcols              the recursive partitioning on the columns\n\nOutput Argument\n\ndvec                the GHWT expansion coefficients (not redundant)\n\nCopyright 2019 The Regents of the University of California\n\nImplemented by Yiqun Shao (Adviser: Dr. Naoki Saito)\n\n\n\n\n\n","category":"method"},{"location":"functions/GHWT/#MultiscaleGraphSignalTransforms.GHWT_2d.ghwt_analysis_2d-Tuple{Matrix{Float64}, GraphPart, GraphPart}","page":"Generalized Haar-Walsh Transform","title":"MultiscaleGraphSignalTransforms.GHWT_2d.ghwt_analysis_2d","text":"dmatrix = ghwt_analysis_2d(matrix::Array{Float64,2}, GProws::GraphPart, GPcols::GraphPart)\n\nFor a matrix, equipped with row and column weight recursive partitionings and weight matrices, generate the redundant matrix of GHWT expansion coefficients.\n\nInput Arguments\n\nmatrix              the matrix to be analyzed    GProws              the recursive partitioning on the rows    GPcols              the recursive partitioning on the columns\n\nOutput Arguments\n\ndmatrix                the GHWT dictionary expansion coefficients\n\nCopyright 2019 The Regents of the University of California\n\nImplemented by Yiqun Shao (Adviser: Dr. Naoki Saito)\n\n\n\n\n\n","category":"method"},{"location":"functions/GHWT/#MultiscaleGraphSignalTransforms.GHWT_2d.ghwt_bestbasis_2d-Tuple{Matrix{Float64}, GraphPart, GraphPart}","page":"Generalized Haar-Walsh Transform","title":"MultiscaleGraphSignalTransforms.GHWT_2d.ghwt_bestbasis_2d","text":"dvec, BSrows, BScols = ghwt_2d_bestbasis(matrix::Array{Float64,2},GProws::GraphPart,GPcols::GraphPart,\ncostfun_rows::Any = 1.0, costfun_cols::Any = 1.0, flatten_rows::Any = 1.0, flatten_cols::Any = 1.0)\n\nFor a matrix, equipped with row and column weight recursive partitionings and weight matrices, generate the (non-redundant) matrix of GHWT expansion coefficients, using the best basis algorithm to select best bases for the rows and columns\n\nInput Argument\n\nmatrix              the matrix to be analyzed\nGProws              the recursive partitioning on the rows\nGPcols              the recursive partitioning on the columns\ncostfun_rows        the cost functional to be used for the rows\ncostfun_cols        the cost functional to be used for the columns\nflatten_rows        the method for flattening vector-valued data to scalar-valued data for the rows\nflatten_cols        the method for flattening vector-valued data to scalar-valued data for the columns\n\nOutput Argument\n\ndvec                the GHWT expansion coefficients (not redundant)\nBSrows              the best basis on the rows\nBScols              the best basis on the columns\n\nCopyright 2019 The Regents of the University of California\n\nImplemented by Yiqun Shao (Adviser: Dr. Naoki Saito)\n\n\n\n\n\n","category":"method"},{"location":"functions/HGLET/#(Lapped)-Hierarchical-Graph-Laplacian-Eigen-Transform","page":"Hierarchical Graph Laplacian Eigen Transform","title":"(Lapped) Hierarchical Graph Laplacian Eigen Transform","text":"","category":"section"},{"location":"functions/HGLET/","page":"Hierarchical Graph Laplacian Eigen Transform","title":"Hierarchical Graph Laplacian Eigen Transform","text":"Pages = [\"HGLET.md\"]","category":"page"},{"location":"functions/HGLET/#MultiscaleGraphSignalTransforms.HGLET.HGLET_Analysis","page":"Hierarchical Graph Laplacian Eigen Transform","title":"MultiscaleGraphSignalTransforms.HGLET.HGLET_Analysis","text":"function HGLET_Analysis(G::GraphSig, GP::GraphPart, gltype::Symbol = :L)\n\nFor a GraphSig object 'G', generate the matrix of HGLET expansion\ncoefficients corresponding to the eigenvectors of specified version of\nthe graph Laplacian matrix, i.e., either L, Lrw, or Lsym\n\nInput Arguments\n\nG:  a GraphSig object\nGP: a GraphPart object\ngltype: :L, :Lrw, or :Lsym, indicating which eigenvectors are used\n\nOutput Argument\n\ndmatrix: the matrix of expansion coefficients using the specific GL matrix\n\n\n\n\n\n","category":"function"},{"location":"functions/HGLET/#MultiscaleGraphSignalTransforms.HGLET.HGLET_Analysis_All-Tuple{GraphSig, GraphPart}","page":"Hierarchical Graph Laplacian Eigen Transform","title":"MultiscaleGraphSignalTransforms.HGLET.HGLET_Analysis_All","text":"function HGLETAnalysisAll(G::GraphSig, GP::GraphPart)\n\nFor a GraphSig object 'G', generate the 3 matrices of HGLET expansion \ncoefficients corresponding to the eigenvectors of L, Lrw and Lsym\n\nInput Arguments\n\nG:  a GraphSig object\nGP: a GraphPart object\n\nOutput Argument\n\ndmatrixH:        the matrix of expansion coefficients for L\ndmatrixHrw:      the matrix of expansion coefficients for Lrw\ndmatrixHsym:     the matrix of expansion coefficients for Lsym\n\n\n\n\n\n","category":"method"},{"location":"functions/HGLET/#MultiscaleGraphSignalTransforms.HGLET.HGLET_BestBasis-Tuple{GraphPart}","page":"Hierarchical Graph Laplacian Eigen Transform","title":"MultiscaleGraphSignalTransforms.HGLET.HGLET_BestBasis","text":"function HGLET_BestBasis(GP::GraphPart;      dmatrix::Array{Float64,3} = Array{Float64,3}(undef,0,0,0),     gltype::Symbol = :L, cfspec::Any = 0.1, flatten::Any = 1)\n\nSelect the HGLET best basis from the input matrix of expansion coefficients\n\nInput Arguments\n\nGP:      a GraphPart object\ndmatrix: the matrix of HGLET expansion coefficients \ngltype:  the type of graph Laplacian matrix used for HGLET dictionary   (default = :L)\ncfspec: the cost functional specification to be used: see utils.jl   for the detail. If it's a number, say, p, then the l^p norm is used.   If it's a function, then that function is used. Default is 0.1, i.e., l^0.1\nflatten: the method for flattening vector-valued data to scalar-valued data;   If it's a number, say, p, then the sum of the l^p norm is computed.   There are many other options, such as :ash, :entropy, etc. See utils.jl   for the detail. Default is 1, i.e, the sum of the l^1 norm of the coefs.\n\nOutput Argument\n\ndvec: the vector of expansion coefficients corresponding to the bestbasis\nBS:   a BasisSpec object which specifies the best basis\n\n\n\n\n\n","category":"method"},{"location":"functions/HGLET/#MultiscaleGraphSignalTransforms.HGLET.HGLET_GHWT_BestBasis-Tuple{GraphPart}","page":"Hierarchical Graph Laplacian Eigen Transform","title":"MultiscaleGraphSignalTransforms.HGLET.HGLET_GHWT_BestBasis","text":"function HGLETGHWTBestBasis(GP::GraphPart;      dmatrixH::Array{Float64,3} = Array{Float64,3}(undef,0,0,0),     dmatrixHrw::Array{Float64,3} = Array{Float64,3}(undef,0,0,0),      dmatrixHsym::Array{Float64,3} = Array{Float64,3}(undef,0,0,0),     dmatrixG::Array{Float64,3} = Array{Float64,3}(undef,0,0,0),      cfspec::Any = 0.1,flatten::Any = 1)\n\nSelect the best basis from several matrices of expansion coefficients\n\nInput Arguments\n\ndmatrixH:    the matrix of HGLET expansion coefficients ==> eigenvectors of L\ndmatrixHrw:  the matrix of HGLET expansion coefficients ==> eigenvectors of Lrw\ndmatrixHsym: the matrix of HGLET expansion coefficients ==> eigenvectors of Lsym\ndmatrixG:    the matrix of GHWT expansion coefficients\nGP:          a GraphPart object\ncfspec: the cost functional specification to be used: see utils.jl   for the detail. If it's a number, say, p, then the l^p norm is used.   If it's a function, then that function is used. Default is 0.1, i.e., l^0.1\nflatten: the method for flattening vector-valued data to scalar-valued data;   If it's a number, say, p, then the sum of the l^p norm is computed.   There are many other options, such as :ash, :entropy, etc. See utils.jl   for the detail. Default is 1, i.e, the sum of the l^1 norm of the coefs.\n\nOutput Argument\n\ndvec:     the vector of expansion coefficients corresponding to the bestbasis\nBS:       a BasisSpec object which specifies the best basis\ntrans:    specifies which transform was used for that portion of the signal:   00 = HGLET with L   01 = HGLET with Lrw   10 = HGLET with Lsym   11 = GHWT\n\n\n\n\n\n","category":"method"},{"location":"functions/HGLET/#MultiscaleGraphSignalTransforms.HGLET.HGLET_GHWT_BestBasis_minrelerror-Tuple{GraphPart, GraphSig}","page":"Hierarchical Graph Laplacian Eigen Transform","title":"MultiscaleGraphSignalTransforms.HGLET.HGLET_GHWT_BestBasis_minrelerror","text":"function HGLETGHWTBestBasis_minrelerror(GP::GraphPart, G::GraphSig;     dmatrixH::Array{Float64,3} = Array{Float64,3}(undef,0,0,0),      dmatrixHrw::Array{Float64,3} = Array{Float64,3}(undef,0,0,0),     dmatrixHsym::Array{Float64,3} = Array{Float64,3}(undef,0,0,0),     dmatrixG::Array{Float64,3} = Array{Float64,3}(undef,0,0,0),      compare::Bool = true)\n\nFind the best basis for approximating the signal 'G' by performing the \n    best basis search with a range of tau-measures as cost functionals\n    (tau = 0.1,0.2,...,1.9) and minimizing the relative error.\n\nInput argument:\n\ndmatrixH: the matrix of HGLET expansion coefficients ==> eigenvectors of L\ndmatrixHrw: the matrix of HGLET expansion coefficients ==> eigenvectors of Lrw\ndmatrixHsym: the matrix of HGLET expansion coefficients ==> eigenvectors of Lsym\ndmatrixG: the matrix of GHWT expansion coefficients\nGP: a GraphPart object\nG: the GraphSig object\ncompare: if it is false, don't compare the hybrid best basis to the GHWT fine-to-coarse best basis\n\nOutput argument:\n\ndvec: the vector of expansion coefficients corresponding to the bestbasis\nBS: a BasisSpec object which specifies the best basis\ntrans: specifies which transform was used for that portion of the signal   00 = HGLET with L   01 = HGLET with Lrw   10 = HGLET with Lsym   11 = GHWT\ntau: the tau that yields the smallest relative error\n\n\n\n\n\n","category":"method"},{"location":"functions/HGLET/#MultiscaleGraphSignalTransforms.HGLET.HGLET_GHWT_Synthesis-Tuple{Matrix{Float64}, GraphPart, BasisSpec, Matrix{Bool}, GraphSig}","page":"Hierarchical Graph Laplacian Eigen Transform","title":"MultiscaleGraphSignalTransforms.HGLET.HGLET_GHWT_Synthesis","text":"function HGLETGHWTSynthesis(dvec::Matrix{Float64},GP::GraphPart,BS::BasisSpec,trans::Array{Bool,2},G::GraphSig)\n\nGiven a vector of HGLET & GHWT expansion coefficients, info about the\ngraph partitioning, and the choice of basis and corresponding transforms,\nreconstruct the signal.\n\nInput Arguments\n\ndvec:   the expansion coefficients corresponding to the chosen basis\nGP:     a GraphPart object\nBS:     a BasisSpec object\ntrans:  a specification of the transforms used for the HGLET-GHWT hybrid transform   00 = HGLET with L   01 = HGLET with Lrw   10 = HGLET with Lsym   11 = GHWT\nG:      a GraphSig object\n\nOutput Argument\n\nf:      the reconstructed signal\nGS:     the reconstructed GraphSig object\n\n\n\n\n\n","category":"method"},{"location":"functions/HGLET/#MultiscaleGraphSignalTransforms.HGLET.HGLET_Synthesis-Tuple{Matrix{Float64}, GraphPart, BasisSpec, GraphSig}","page":"Hierarchical Graph Laplacian Eigen Transform","title":"MultiscaleGraphSignalTransforms.HGLET.HGLET_Synthesis","text":"function HGLET_Synthesis(dvec::Vector{Float64}, GP::GraphPart, BS::BasisSpec,                          G::GraphSig; gltype::Symbol = :L)\n\nInput Arguments\n\ndvec: the expansion coefficients corresponding to the chosen basis\nGP: a GraphPart object\nBS: a BasisSpec object\nG: a GraphSig object\ngltype: :L, :Lrw, or :Lsym, indicating which eigenvectors are used\n\nOutput Argument\n\nf: the reconstructed signal\nGS: the reconstructed GraphSig object\n\n\n\n\n\n","category":"method"},{"location":"functions/HGLET/#MultiscaleGraphSignalTransforms.HGLET.HGLET_jkl-Tuple{GraphPart, Int64, Int64}","page":"Hierarchical Graph Laplacian Eigen Transform","title":"MultiscaleGraphSignalTransforms.HGLET.HGLET_jkl","text":"function HGLET_jkl(GP::GraphPart, drow::Int, dcol::Int)\n\nGenerate the (j,k,l) indices for the HGLET basis vector corresponding to\n    the coefficient dmatrix(drow,dcol)\n\nInput Arguments\n\nGP:    a GraphPart object\ndrow:  the row of the expansion coefficient\ndcol:  the column of the expansion coefficient\n\nOutput Argument\n\nj: the level index of the expansion coefficient\nk: the subregion index of the expansion coefficient\nl: the eigenvector index of the expansion coefficient\n\n\n\n\n\n","category":"method"},{"location":"functions/HGLET/#MultiscaleGraphSignalTransforms.HGLET_dictionary-Tuple{GraphPart, GraphSig}","page":"Hierarchical Graph Laplacian Eigen Transform","title":"MultiscaleGraphSignalTransforms.HGLET_dictionary","text":"HGLET_dictionary(GP::GraphPart, G::GraphSig; gltype::Symbol = :L)\n\nassemble the whole HGLET dictionary\n\nInput Arguments\n\nGP: a GraphPart object\nG:  a GraphSig object\ngltype: :L or :Lsym\n\nOutput Argument\n\ndictionary: the HGLET dictionary\n\n\n\n\n\n","category":"method"},{"location":"functions/HGLET/#MultiscaleGraphSignalTransforms.LPHGLET_Analysis_All-Tuple{GraphSig, GraphPart}","page":"Hierarchical Graph Laplacian Eigen Transform","title":"MultiscaleGraphSignalTransforms.LPHGLET_Analysis_All","text":"function LPHGLET_Analysis_All(G::GraphSig, GP::GraphPart; œµ::Float64 = 0.3)\n\nFor a GraphSig object 'G', generate the 2 matrices of Lapped-HGLET expansion coefficients corresponding to the eigenvectors of L and Lsym\n\nInput Arguments\n\nG:  a GraphSig object\nGP: a GraphPart object\nœµ: relative action bandwidth (default: 0.3)\n\nOutput Argument\n\ndmatrixlH:        the matrix of expansion coefficients for L\ndmatrixlHsym:     the matrix of expansion coefficients for Lsym\nGP:              a GraphPart object\n\n\n\n\n\n","category":"method"},{"location":"functions/HGLET/#MultiscaleGraphSignalTransforms.LPHGLET_Synthesis-Tuple{Matrix{Float64}, GraphPart, BasisSpec, GraphSig}","page":"Hierarchical Graph Laplacian Eigen Transform","title":"MultiscaleGraphSignalTransforms.LPHGLET_Synthesis","text":"function LPHGLET_Synthesis(dvec::Vector{Float64}, GP::GraphPart, BS::BasisSpec, G::GraphSig; gltype::Symbol = :L, œµ::Float64 = 0.3)\n\nPerform Lapped-HGLET Synthesis transform\n\nInput Arguments\n\ndvec: the expansion coefficients corresponding to the chosen basis\nGP: a GraphPart object\nBS: a BasisSpec object\nG: a GraphSig object\ngltype: :L or :Lsym, indicating which eigenvectors are used\nœµ: relative action bandwidth (default: 0.3)\n\nOutput Argument\n\nf: the reconstructed signal\nGS: the reconstructed GraphSig object\n\n\n\n\n\n","category":"method"},{"location":"functions/HGLET/#MultiscaleGraphSignalTransforms.LPHGLET_dictionary-Tuple{GraphPart, GraphSig}","page":"Hierarchical Graph Laplacian Eigen Transform","title":"MultiscaleGraphSignalTransforms.LPHGLET_dictionary","text":"LPHGLET_dictionary(GP::GraphPart, G::GraphSig; gltype::Symbol = :L, œµ::Float64 = 0.3)\n\nassemble the whole LP-HGLET dictionary\n\nInput Arguments\n\nGP: a GraphPart object\nG:  a GraphSig object\ngltype: :L or :Lsym\nœµ: relative action bandwidth (default: 0.3)\n\nOutput Argument\n\ndictionary: the LP-HGLET dictionary\n\n\n\n\n\n","category":"method"}]
}
