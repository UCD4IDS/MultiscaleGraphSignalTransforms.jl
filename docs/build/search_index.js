var documenterSearchIndex = {"docs":
[{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Modules = [MultiscaleGraphSignalTransforms]","category":"page"},{"location":"functions/#MultiscaleGraphSignalTransforms.Bilinear_rendering-Tuple{Any, Any}","page":"Functions","title":"MultiscaleGraphSignalTransforms.Bilinear_rendering","text":"Bilinear_rendering(X, Img_Mat)\n\nNN_RENDERING generates a rendering signal at each point of X from the image Img_Mat by bilinear interpolation method.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.GraphSig_Plot-Tuple{GraphSig}","page":"Functions","title":"MultiscaleGraphSignalTransforms.GraphSig_Plot","text":"GraphSig_Plot(G::GraphSig; symmetric::Bool = false,\n  markersize::Float64 = 2.,\n  markercolor::Symbol = :balance,\n  markershape::Symbol = :circle,\n  markerstrokewidth::Float64 = 1.0,\n  markerstrokealpha::Float64 = 1.0,\n  markervaluevaries::Bool = true,\n  linewidth::Float64 = 1.,\n  linecolor::Symbol = :blue,\n  linestyle::Symbol = :solid,\n  clim::Tuple{Float64,Float64} = (0., 0.),\n  notitle::Bool = false, nocolorbar::Bool = false, nolegend::Bool = true,\n  stemplot::Bool = false, sortnodes::Bool = false)\n\nDisplay a plot of the data in a GraphSig object\n\nInput Argument\n\nG::GraphSig:        an input GraphSig object\nsymmetric           symmetrize the colorbar\nmarkersize          the size of the nodes\nmarkercolor         markercolor scheme\nmarkershape         shape of marker\nmarkerstrokewidth   width of marker stroke\nmarkerstrokealpha   capacity of marker stroke\nmarkervaluevaries   if the marker color depends on the signal value\nlinewidth           the width of the lines in gplot\nlinecolor           the color of the lines (1D) / graph edges (2D & 3D)\nlinestyle:          the style of line\nnotitle             display a title\nnocolorbar          display a colorbar\nnolegend            display a legend\nstemplot            use a stem plot\nclim                specify the dynamic display range\nsortnodes           plot the signal values from smallest to largest in magnitude\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.HGLET_dictionary-Tuple{GraphPart, GraphSig}","page":"Functions","title":"MultiscaleGraphSignalTransforms.HGLET_dictionary","text":"HGLET_dictionary(GP::GraphPart, G::GraphSig; method::Symbol = :L)\n\nassemble the whole HGLET dictionary\n\nInput Arguments\n\nGP: a GraphPart object\nG:  a GraphSig object\nmethod: :L or :Lsym\n\nOutput Argument\n\ndictionary: the HGLET dictionary\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.K_functional-Tuple{Vector{Float64}, Vector{Float64}, Matrix{Float64}, Matrix{Float64}, Vector{Float64}}","page":"Functions","title":"MultiscaleGraphSignalTransforms.K_functional","text":"K_functional(ùê©::Vector{Float64}, ùê™::Vector{Float64}, ùöΩ::Matrix{Float64},\n             ‚àáùöΩ::Matrix{Float64}, ùõå::Vector{Float64}; length::Any = 1,\n             T::Any = :Inf, dt::Float64 = 0.5/maximum(ùõå), tol::Float64 = 1e-5)\n\ncomputes the K_functional between two vector meassures ùê© and ùê™ on a graph.\n\nInput Argument\n\nùê©::Vector{Float64}: the source vector measure.\nùê™::Vector{Float64}: the destination vector measure.\nùöΩ::Matrix{Float64}: matrix of the unweighted graph Laplacian eigenvectors.\n‚àáùöΩ::Matrix{Float64}: gradient of unweighted graph Laplacian eigenvectors.\nùõå::Vector{Float64}: vector of eigenvalues.\nlength::Any: vector of edge lengths (default: 1 represents unweighted graphs)\nT::Any: the stopping time T in K_functional (default: :Inf)\ntol::Float64: tolerance for convergence (default: 1e-5)\n\nOutput Argument\n\nK::Float64: TSD distance d_{TSD}(p, q; T).\nE::Float64: an estimated upper bound on the absolute error. In general,   E <= tol * norm(K).\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.LPHGLET_Analysis_All-Tuple{GraphSig, GraphPart}","page":"Functions","title":"MultiscaleGraphSignalTransforms.LPHGLET_Analysis_All","text":"function LPHGLET_Analysis_All(G::GraphSig, GP::GraphPart; œµ::Float64 = 0.3)\n\nFor a GraphSig object 'G', generate the 2 matrices of Lapped-HGLET expansion coefficients corresponding to the eigenvectors of L and Lsym\n\nInput Arguments\n\nG:  a GraphSig object\nGP: a GraphPart object\nœµ: relative action bandwidth (default: 0.3)\n\nOutput Argument\n\ndmatrixlH:        the matrix of expansion coefficients for L\ndmatrixlHsym:     the matrix of expansion coefficients for Lsym\nGP:              a GraphPart object\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.LPHGLET_Synthesis-Tuple{Matrix{Float64}, GraphPart, BasisSpec, GraphSig}","page":"Functions","title":"MultiscaleGraphSignalTransforms.LPHGLET_Synthesis","text":"function LPHGLET_Synthesis(dvec::Vector{Float64}, GP::GraphPart, BS::BasisSpec, G::GraphSig; method::Symbol = :L, œµ::Float64 = 0.3)\n\nPerform Lapped-HGLET Synthesis transform\n\nInput Arguments\n\ndvec: the expansion coefficients corresponding to the chosen basis\nGP: a GraphPart object\nBS: a BasisSpec object\nG: a GraphSig object\nmethod: :L or :Lsym, indicating which eigenvectors are used\nœµ: relative action bandwidth (default: 0.3)\n\nOutput Argument\n\nf: the reconstructed signal\nGS: the reconstructed GraphSig object\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.LPHGLET_dictionary-Tuple{GraphPart, GraphSig}","page":"Functions","title":"MultiscaleGraphSignalTransforms.LPHGLET_dictionary","text":"LPHGLET_dictionary(GP::GraphPart, G::GraphSig; method::Symbol = :L, œµ::Float64 = 0.3)\n\nassemble the whole LP-HGLET dictionary\n\nInput Arguments\n\nGP: a GraphPart object\nG:  a GraphSig object\nmethod: :L or :Lsym\nœµ: relative action bandwidth (default: 0.3)\n\nOutput Argument\n\ndictionary: the LP-HGLET dictionary\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.NGWP_jkl-Tuple{GraphPart, Int64, Int64}","page":"Functions","title":"MultiscaleGraphSignalTransforms.NGWP_jkl","text":"function NGWP_jkl(GP_star::GraphPart, drow::Int, dcol::Int)\n\nGenerate the (j,k,l) indices for the NGWP basis vector corresponding to the coefficient dmatrix(drow,dcol)\n\nInput Arguments\n\nGP_star::GraphPart: a GraphPart object of the dual grpah\ndrow::Int: the row of the expansion coefficient\ndcol::Int: the column of the expansion coefficient\n\nOutput Argument\n\nj: the level index of the expansion coefficient\nk: the subregion in dual graph's index of the expansion coefficient\nl: the tag of the expansion coefficient\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.NN_rendering-Tuple{Any, Any}","page":"Functions","title":"MultiscaleGraphSignalTransforms.NN_rendering","text":"NN_rendering(X, Img_Mat)\n\nNN_RENDERING generates a rendering signal at each point of X from the image Img_Mat by nearest neighbor method.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.ROT_Distance-Tuple{Any, Any, SparseMatrixCSC{Int64, Int64}}","page":"Functions","title":"MultiscaleGraphSignalTransforms.ROT_Distance","text":"ROT_Distance(A, B, Q; edge_length = 1, Œ± = 1.0)\n\ncomputes the ROT distance matrix from A's column vectors to B's column vectors. If A, B are vector inputs, then it also returns the cost value and the optimal transport plan.\n\nInput Argument\n\nA::Any: a vector or matrix whose columns are initial probability measures.\nB::Any: a vector or matrix whose columns are terminal probability measures.\nQ::SparseMatrixCSC{Int64,Int64}: the unweighted incidence matrix of the graph.\nedge_length::Any: the length vector (default: 1 represents unweighted graphs)\nŒ±::Float64: default is 1.0. ROT parameter.\nretPlan::Bool: an indicator if return the optimal plan (default: false)\n\nOutput Argument\n\ndis::Matrix{Float64}: distance matrix, dis[i,j] = d_{ROT}(a·µ¢, b‚±º; Œ±).\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.SunFlowerGraph-Tuple{}","page":"Functions","title":"MultiscaleGraphSignalTransforms.SunFlowerGraph","text":"SunFlowerGraph(; N = 400)\n\nSUNFLOWERGRAPH construct a simple weighted sunflower graph with N vertices. Edge weights are the reciprocal of Euclidean distances.\n\nInput Arguments\n\nN::Int64: default is 400, the number of vertices. Requires N > 26.\n\nOutput Argument\n\nG::SimpleWeightedGraph{Int64,Float64}: a simple weighted graph of the sunflower.\nL::Matrix{Float64}: the weighted unnormalized graph Laplacian matrix.\nX::Matrix{Float64}: a matrix whose i-th row represent the 2D coordinates of the i-th node.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.alternating_numbers-Tuple{Any}","page":"Functions","title":"MultiscaleGraphSignalTransforms.alternating_numbers","text":"alternating_numbers(n)\n\nALTERNATING_NUMBERS e.g., n = 5, returns [1,5,2,4,3]; n = 6, returns [1,6,2,5,3,4]\n\nInput Arguments\n\nn::Int64: number of nodes in x-axis.\n\nOutput Argument\n\narr::Array{Int64}: result array.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.approx_error_plot-Tuple{Vector{Vector{Float64}}}","page":"Functions","title":"MultiscaleGraphSignalTransforms.approx_error_plot","text":"approx_error_plot(DVEC::Vector{Vector{Float64}}; frac::Float64 = 0.50)\n\ndraw relative approx. error w.r.t. fraction of coefficients retained (FCR)\n\nInput Arguments\n\nDVEC::Vector{Vector{Float64}}: a list of expansion coefficients.\nfraction::Float64: default is 0.5.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.approx_error_plot2-Tuple{Vector{Vector{Float64}}}","page":"Functions","title":"MultiscaleGraphSignalTransforms.approx_error_plot2","text":"approx_error_plot2(DVEC::Vector{Vector{Float64}}; frac::Float64 = 0.50)\n\ndraw relative approx. error w.r.t. fraction of coefficients retained (FCR) in dissertation\n\nInput Arguments\n\nDVEC::Vector{Vector{Float64}}: a list of expansion coefficients.\nfraction::Float64: default is 0.5.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.bs_level-Tuple{GraphPart, Int64}","page":"Functions","title":"MultiscaleGraphSignalTransforms.bs_level","text":"BS = bs_level(GP::GraphPart, j::Int, c2f::Bool = true)\n\nSpecify the basis corresponding to level j for a given graph partitioning\n\nInput Arguments\n\nGP::GraphPart: an input GraphPart object\nj::Int: the level to which the basis corresponds (j = 0 is the global level)\nc2f::Bool: a flag for c2f or f2c (default: true, i.e., c2f)\n\nOutput Argument\n\nBS::BasisSpec: a BasisSpec object corresponding to the level j basis\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.bs_walsh-Tuple{GraphPart}","page":"Functions","title":"MultiscaleGraphSignalTransforms.bs_walsh","text":"BS = bs_walsh(GP::GraphPart)\n\nSpecify the walsh basis corresponding to for a given graph partitioning\n\nInput Arguments\n\nGP::GraphPart: an input GraphPart object\n\nOutput Argument\n\nBS::BasisSpec: a BasisSpec object corresponding to the walsh basis\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.bsfull-Tuple{GraphPart, BasisSpec}","page":"Functions","title":"MultiscaleGraphSignalTransforms.bsfull","text":"(levlistfull, levlengthsfull, transfull) = bsfull(GP::GraphPart, BS::BasisSpec, trans::Vector{Bool})\n\nGiven a BasisSpec object, return the full-length, redundant levlist, levlengths, and trans descriptions.\n\nInput Arguments\n\nGP::GraphPart: an input GraphPart object\nBS::BasisSpec: an input BasisSpec object\ntrans::Vector{Bool}: a specification of the transforms used for the HGLET-GHWT hybrid transform (default: null)\nlevlengthsp::Bool: a flag to return levlengthsfull (default: false)\ntransp::Bool: a flag to return transfull (default: false)\n\nOutput Arguments\n\nlevlistfull::Vector{UInt8}: the full-length, redundant levels list description\nlevlengthsfull::Vector{UInt8}: the full-length, redundant levels lengths description\ntransfull::Matrix{Bool}: the full-length, redundant trans description\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.cat_plot-Tuple{Any}","page":"Functions","title":"MultiscaleGraphSignalTransforms.cat_plot","text":"cat_plot(X; marker = nothing, ms = 4)\n\nCAT_PLOT generates a scatter plot figure for cat example, which is for quick viewing of a graph signal within a specific range (i.e., xlims, ylims, zlims). CAT_PLOT!(X; ...) adds a plot to current one.\n\nInput Arguments\n\nX::Matrix{Float64}: 3-dim points.\nmarker::Array{Float64}: default is nothing. Present different colors given   different signal value at each node.\nms::Array{Float64}: default is 4. Present different node sizes given   different signal value at each node.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.characteristic-Tuple{Any, Any}","page":"Functions","title":"MultiscaleGraphSignalTransforms.characteristic","text":"characteristic(list, N)\n\nCHARACTERISTIC gives the characteristic function in n-dim vector space with     values of index in list equal to 1.\n\nInput Arguments\n\nlist::Array{Int}: list of indices.\nN::Int: dimension of the target vector.\n\nOutput Argument\n\nv::Array{Float64}: the n-dim characteristic vector with values of index in list equal to 1.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.compute_SNR-Tuple{Any, Any}","page":"Functions","title":"MultiscaleGraphSignalTransforms.compute_SNR","text":"compute_SNR(f, g)\n\nCOMPUTE_SNR, g = f + œµ, SNR = 20 * log10(norm(f)/norm(g-f)).\n\nInput Arguments\n\nf::Array{Float64}: original signal.\ng::Array{Float64}: noisy signal.\n\nOutput Argument\n\nSNR::Float64: SNR value.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.const_proj_wavelets-Tuple{Any, Any, Any}","page":"Functions","title":"MultiscaleGraphSignalTransforms.const_proj_wavelets","text":"const_proj_wavelets(ùöΩ,vlist,elist; method = \"Modified Gram-Schmidt with Lp Pivoting\")\n\nconstruct projection wavelets, i.e., project Œ¥ ‚àà vlist onto span({œÜ‚±º| j ‚àà elist}).\n\nInput Arguments\n\nùöΩ::Matrix{Float64}: graph Laplacian eigenvectors ùöΩ\nvlist::Array{Int}: the list of considered node indices.\nelist::Array{Int}: the list of considered eigenvector indices.\nmethod::Symbol: default is :MGSLp. other options: :IP (Iterative-Projection),   GS (Gram Schmidt).\n\nOutput Argument\n\nWav::Matrix{Float64}: a matrix whose columns are projected wavelet vectors.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.cost_functional-Tuple{Any}","page":"Functions","title":"MultiscaleGraphSignalTransforms.cost_functional","text":"costfun = cost_functional(cfspec::Any)\n\nDetermine the cost functional to be used by the best-basis algorithm.\n\nInput Argument\n\ncfspec::Any: the specification for the cost functional\n\nOutput Argument\n\ncostfun::Function: the cost functional (as a function_handle)\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.dct1d-Tuple{Any, Any}","page":"Functions","title":"MultiscaleGraphSignalTransforms.dct1d","text":"dct1d(k, N)\n\nDCT1D returns k-th 1D DCT basis vector in R·¥∫.\n\nInput Arguments\n\nk::Int64: ord of DCT basis vector. k = 1,2,...,N.\nN::Int64: vector dimension.\n\nOutput Argument\n\nœÜ::Array{Float64}: k-th 1D DCT basis vector in R·¥∫. (k is 1-indexed)\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.dct2d_basis-Tuple{Any, Any}","page":"Functions","title":"MultiscaleGraphSignalTransforms.dct2d_basis","text":"dct2d_basis(N1, N2)\n\nDCT2D_BASIS returns 2D DCT basis vectors in [0,1] x [0,1] with N1-1 and N2-1 subintervals respectively.\n\nInput Arguments\n\nN1::Int64: number of nodes in x-axis.\nN2::Int64: number of nodes in y-axis.\n\nOutput Argument\n\nùöΩ::Matrix{Float64}: 2D DCT basis vectors.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.dmatrix2dvec-Tuple{Array{Float64, 3}, GraphPart, BasisSpec}","page":"Functions","title":"MultiscaleGraphSignalTransforms.dmatrix2dvec","text":"dvec = dmatrix2dvec(dmatrix::Array{Float64,3}, GP::GraphPart, BS::BasisSpec)\n\nGiven a matrix of expansion coefficients, convert it to a vector. This function assumes that the input coefficient array dmatrix is in the coarse-to-fine format. If BS.c2f == false, then this function internally converts dmatrix into the fine-to-coarse format. Hence, if one supplies the f2c dmatrix, the results become wrong, and the subsequent procedure may result in error.\n\nInput Arguments\n\ndmatrix::Array{Float64,3}: matrices of expansion coefficients\nGP::GraphPart: an input GraphPart object\nBS::BasisSpec: an input BasisSpec object\n\nOutputs Arguments\n\ndvec::Matrix{Float64}: a vector of expansion coefficients\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.dmatrix2dvec-Tuple{Array{Float64, 3}, GraphPart}","page":"Functions","title":"MultiscaleGraphSignalTransforms.dmatrix2dvec","text":"(dvec, BS) = dmatrix2dvec(dmatrix::Array{Float64,3}, GP::GraphPart)\n\nGiven a matrix of expansion coefficients, convert it to a vector.\n\nInput Arguments\n\ndmatrix::Array{Float64,3}: matrices of expansion coefficients\nGP::GraphPart: an input GraphPart object\nBS::BasisSpec: an input BasisSpec object\n\nOutputs Arguments\n\ndvec::Matrix{Float64}: a vector of expansion coefficients\nBS::BasisSpec: an output BasisSpec object\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.dmatrix_flatten-Tuple{Array{Float64, 3}, Any}","page":"Functions","title":"MultiscaleGraphSignalTransforms.dmatrix_flatten","text":"dmatrix_flatten(dmatrix::Array{Float64,3}, flatten::Any)\n\nFlatten dmatrix using the method specified by the string \"flatten\"\n\nInput Arguments\n\ndmatrix::Array{Float64,3}: the matrix of expansion coefficients; after this function is called, it becomes the size of (~, ~, 1).\nflatten::Any: the method for flattening dmatrix (see the code in details)\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.dualgraph-Tuple{Matrix{Float64}}","page":"Functions","title":"MultiscaleGraphSignalTransforms.dualgraph","text":"dualgraph(dist::Matrix{Float64}; method::Symbol = :inverse, œÉ::Float64 = 1.0)\n\nbuild the dual graph's weight matrix based on the given non-trivial eigenvector metric.\n\nInput Arguments\n\ndist::Matrix{Float64}: eigenvector distance matrix\nmethod::Symbol: default is by taking inverse of the distance between   eigenvectors. Ways to build the dual graph edge weights. Option: :inverse,   :gaussian.\nœÉ::Float64: default is 1.0. Gaussian variance parameter.\n\nOutput Argument\n\nG_star::GraphSig: A GraphSig object containing the weight matrix of the   dual graph.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.dvec2dmatrix-Tuple{Matrix{Float64}, GraphPart, BasisSpec}","page":"Functions","title":"MultiscaleGraphSignalTransforms.dvec2dmatrix","text":"dmatrix = dvec2dmatrix(dvec::Matrix{Float64}, GP::GraphPart, BS::BasisSpec)\n\nGiven a vector of expansion coefficients, convert it to a matrix.\n\nInput Arguments\n\ndvec::Matrix{Float64}: a vector of expansion coefficients\nGP::GraphPart: a GraphPart object\nBS::BasisSpec: a BasisSpec object\n\nOutput Argument\n\ndmatrix::Array{Float64,3}: a set of matrices of expansion coefficients\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.dvec_Threshold-Tuple{Matrix{Float64}, String, Float64, GraphPart, BasisSpec}","page":"Functions","title":"MultiscaleGraphSignalTransforms.dvec_Threshold","text":"function dvec_Threshold(dvec::Array{Float64}, SORH::String, keep::Float64,                 GP::GraphPart, BS::BasisSpec)\n\nThreshold HGLET / GHWT coefficients\n\nInput Arguments\n\ndvec::Array{Float64,2}        the vector of expansion coefficients\nSORH::String        use soft ('s') or hard ('h') thresholding\nkeep::Float64        a fraction between 0 and 1 which says how many coefficients should be kept\nGP::GraphPart          a GraphPart object, used to identify scaling coefficients\nBS::BasisSpec          a BasisSpec object, used to identify scaling coefficients\n\nOutput Argument\n\ndvec_new::Vector{Float64}        the thresholded expansion coefficients\nkept::Float64        the number of coefficients kept\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.eigDAG_Distance-Tuple{Any, Any, Any}","page":"Functions","title":"MultiscaleGraphSignalTransforms.eigDAG_Distance","text":"eigDAG_Distance(ùöΩ, Q, numEigs; edge_weights = 1)\n\ncompute DAG distances between pairwise graph Laplacian eigenvectors.\n\nInput Arguments\n\nùöΩ::Matrix{Float64}: matrix of graph Laplacian eigenvectors, ùúô‚±º‚Çã‚ÇÅ (j = 1,...,size(ùöΩ,1)).\nQ::Matrix{Float64}: incidence matrix of the graph.\nnumEigs::Int64: number of eigenvectors considered.\nedge_weight::Any: default value is 1, stands for unweighted graph   (i.e., all edge weights equal to 1). For weighted graph, edge_weight is the   weights vector, which stores the affinity weight of each edge.\n\nOutput Argument\n\ndis::Matrix{Float64}: a numEigs x numEigs distance matrix, dis[i,j] = d_DAG(ùúô·µ¢‚Çã‚ÇÅ, ùúô‚±º‚Çã‚ÇÅ).\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.eigHAD_Affinity-Tuple{Any, Any}","page":"Functions","title":"MultiscaleGraphSignalTransforms.eigHAD_Affinity","text":"eigHAD_Affinity(ùöΩ, ùõå; indexEigs = 1:size(ùöΩ,2))\n\nEIGHAD_AFFINITY compute Hadamard (HAD) affinity between pairwise graph Laplacian eigenvectors.\n\nInput Arguments\n\nùöΩ::Matrix{Float64}: matrix of graph Laplacian eigenvectors, ùúô‚±º‚Çã‚ÇÅ (j = 1,...,size(ùöΩ,1)).\nùõå::Array{Float64}: array of eigenvalues. (ascending order)\nindexEigs::Int: default is all eigenvectors, indices of eigenvectors considered.\n\nOutput Argument\n\nA::Matrix{Float64}: a numEigs x numEigs affinity matrix, A[i,j] = a_HAD(ùúô·µ¢‚Çã‚ÇÅ, ùúô‚±º‚Çã‚ÇÅ).\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.eigHAD_Distance-Tuple{Any, Any}","page":"Functions","title":"MultiscaleGraphSignalTransforms.eigHAD_Distance","text":"eigHAD_Distance(ùöΩ, ùõå; indexEigs = 1:size(ùöΩ,2))\n\ncompute HAD \"distance\" (not really a distance) between pairwise graph Laplacian eigenvectors, i.e., dHAD(ùúô·µ¢‚Çã‚ÇÅ, ùúô‚±º‚Çã‚ÇÅ) = ‚àö(1 - aHAD(ùúô·µ¢‚Çã‚ÇÅ, ùúô‚±º‚Çã‚ÇÅ)¬≤).\n\nInput Arguments\n\nùöΩ::Matrix{Float64}: matrix of graph Laplacian eigenvectors, ùúô‚±º‚Çã‚ÇÅ (j = 1,...,size(ùöΩ,1)).\nùõå::Array{Float64}: array of eigenvalues. (ascending order)\nindexEigs::Int: default is all eigenvectors, indices of eigenvectors considered.\n\nOutput Argument\n\ndis::Matrix{Float64}: the HAD distance matrix, dis[i,j] = d_HAD(ùúô·µ¢‚Çã‚ÇÅ, ùúô‚±º‚Çã‚ÇÅ).\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.eigROT_Distance-Tuple{Matrix{Float64}, SparseMatrixCSC{Int64, Int64}}","page":"Functions","title":"MultiscaleGraphSignalTransforms.eigROT_Distance","text":"eigROT_Distance(P, Q; edge_length = 1, Œ± = 1.0)\n\ncomputes the ROT distance matrix of P's column vectors on a graph.\n\nInput Argument\n\nP::Matrix{Float64}: a matrix whose columns are vector measures with the same total mass.\nQ::SparseMatrixCSC{Int64,Int64}: the unweighted incidence matrix of the graph.\nedge_length::Any: the length vector (default: 1 represents unweighted graphs)\nŒ±::Float64: default is 1.0. ROT parameter.\n\nOutput Argument\n\ndis::Matrix{Float64}: distance matrix, dis[i,j] = d_{ROT}(p·µ¢, p‚±º; Œ±).\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.eigTSD_Distance-Tuple{Matrix{Float64}, Matrix{Float64}, Vector{Float64}, SparseMatrixCSC{Int64, Int64}}","page":"Functions","title":"MultiscaleGraphSignalTransforms.eigTSD_Distance","text":"eigTSD_Distance(P::Matrix{Float64}, ùöΩ::Matrix{Float64}, ùõå::Vector{Float64},\n                Q::SparseMatrixCSC{Int64,Int64}; length::Any = 1,\n                T::Any = :Inf, tol::Float64 = 1e-5)\n\ncomputes the TSD distance matrix of P's column vectors on a graph.\n\nInput Argument\n\nP::Matrix{Float64}: vector measures with the same total mass 0.\nùöΩ::Matrix{Float64}: matrix of the unweighted graph Laplacian eigenvectors.\nùõå::Vector{Float64}: vector of eigenvalues.\nQ::SparseMatrixCSC{Int64,Int64}: the unweighted incidence matrix.\nlength::Any: vector of edge lengths (default: 1 represents unweighted graphs)\nT::Any: the stopping time T in K_functional (default: :Inf)\ntol::Float64: tolerance for integral convergence (default: 1e-5)\n\nOutput Argument\n\ndis::Matrix{Float64}: distance matrix, d_{TSD}(œÜ·µ¢, œÜ‚±º; T).\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.eigsROT_Distance-Tuple{Matrix{Float64}, SparseMatrixCSC{Float64, Int64}, Matrix{Float64}}","page":"Functions","title":"MultiscaleGraphSignalTransforms.eigsROT_Distance","text":"eigsROT_Distance(P::Matrix{Float64}, W::SparseMatrixCSC{Float64, Int64}, X::Matrix{Float64}; Œ±::Float64 = 1.0)\n\ncomputes the sROT distance matrix of P's column vectors on a (unweighted) tree.\n\nInput Argument\n\nP::Matrix{Float64}: a matrix whose columns are vector measures with the same total mass.\nW::SparseMatrixCSC{Float64, Int64}: the weight matrix of the tree.\nX::Matrix{Float64}: the node positions (i-th row represents node i's location)\nŒ±::Float64: default is 1.0. ROT parameter.\n\nOutput Argument\n\ndist_sROT::Matrix{Float64}: distance matrix, distsROT[i,j] = d{sROT}(p·µ¢, p‚±º; Œ±).\nWs::SparseMatrixCSC{Float64, Int64}: the weight matrix of the simplified tree.\nXs::Matrix{Float64}: the node locations of the simplified tree\nùöØ::Matrix{Float64}: the shortened pmfs from P.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.find_subgraph_inds-Tuple{SparseMatrixCSC{Float64, Int64}}","page":"Functions","title":"MultiscaleGraphSignalTransforms.find_subgraph_inds","text":"find_subgraph_inds(Wc::SparseMatrixCSC{Float64, Int64})\n\nfind all subgraph indices of a tree. (subgraph includes: branches and junctions)\n\nInput Argument\n\nWc::SparseMatrixCSC{Float64, Int64}: the weight matrix of the tree chopped by   the junctions.\n\nOutput Argument\n\nInd::Matrix{Float64}: a matrix whose columns represent the subgraph node   indices in binary form.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.findminimum-Tuple{Any, Any}","page":"Functions","title":"MultiscaleGraphSignalTransforms.findminimum","text":"findminimum(v, n)\n\nFINDMINIMUM finds the first n smallest elements' indices.\n\nInput Arguments\n\nv::Array{Float64}: the candidate values for selection.\nn::Int: number of smallest elements for consideration.\n\nOutput Argument\n\nidx::Array{Int}: n smallest elements' indices.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.frame_approx-Tuple{Any, Any, Any}","page":"Functions","title":"MultiscaleGraphSignalTransforms.frame_approx","text":"frame_approx(f, U, V; num_kept = length(f))\n\napproximate signal f by the frame U.\n\nInput Arguments\n\nf::Vector{Float64}: input graph signal\nU::Matrix{Float64}: a frame operator (matrix or dictionary)\nV::Matrix{Float64}: the dual frame operator of U\nnum_kept::Int64: number of kept coefficients (NCR)\n\nOutput Argument\n\nrel_error::Vector{Float64}: the relative errors\nf_approx::Vector{Float64}: the approximated signal\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.freq_band_matrix-Tuple{Any, Any}","page":"Functions","title":"MultiscaleGraphSignalTransforms.freq_band_matrix","text":"freq_band_matrix(ls,n)\n\nFREQ_BAND_MATRIX provides characteristic diagonal matrix, which is useful for spectral graph filters design.\n\nInput Arguments\n\nls::Array{Int}: list of indices.\nn::Int: dimension of the target vector.\n\nOutput Argument\n\nD::Array{Float64}: the zero/one diagonal matrix.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.getall_expansioncoeffs-Tuple{GraphSig, GraphPart, Array{Float64, 3}, Array{Float64, 3}, Matrix{Float64}}","page":"Functions","title":"MultiscaleGraphSignalTransforms.getall_expansioncoeffs","text":"getall_expansioncoeffs(G_Sig::GraphSig, GP_star::GraphPart, VM_NGWP::Array{Float64,3}, PC_NGWP::Array{Float64,3}, ùöΩ::Matrix{Float64})\n\nget all expansion coefficients of f via all methods in NGWP.jl and MTSG.jl\n\nInput Arguments\n\nG_Sig::GraphSig: GraphSig of the primal graph\nGP_star::GraphPart: GraphPart of the dual graph\nVM_NGWP::Array{Float64,3}: varimax NGWP.\nPC_NGWP::Array{Float64,3}: pair-clustering NGWP.\nùöΩ::Matrix{Float64}: the matrix of graph Laplacian eigenvectors.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.getall_expansioncoeffs2-Tuple{GraphSig, GraphPart, GraphPart, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Matrix{Float64}, Matrix{Float64}}","page":"Functions","title":"MultiscaleGraphSignalTransforms.getall_expansioncoeffs2","text":"getallexpansioncoeffs2(GSig::GraphSig, GPstar::GraphPart,                                  GPstarLsym::GraphPart,                                  VMNGWP::Array{Float64,3},                                  PCNGWP::Array{Float64,3},                                  LPNGWP::Array{Float64,3},                                  VMNGWPLsym::Array{Float64,3},                                  PCNGWPLsym::Array{Float64,3},                                  LPNGWPLsym::Array{Float64,3},                                  ùöΩ::Matrix{Float64},                                  ùöΩsym::Matrix{Float64})\n\nget all expansion coefficients of f in dissertation via all methods in NGWP.jl and MTSG.jl\n\nInput Arguments\n\nG_Sig::GraphSig: GraphSig of the primal graph\nGP_star::GraphPart: GraphPart of the dual graph\nVM_NGWP::Array{Float64,3}: varimax NGWP.\nPC_NGWP::Array{Float64,3}: pair-clustering NGWP.\nLP_NGWP::Array{Float64,3}: lapped NGWP.\nVM_NGWP_Lsym::Array{Float64,3}: Lsym version of varimax NGWP.\nPC_NGWP_Lsym::Array{Float64,3}: Lsym version of pair-clustering NGWP.\nLP_NGWP_Lsym::Array{Float64,3}: Lsym version of lapped NGWP.\nùöΩ::Matrix{Float64}: the matrix of L eigenvectors.\nùöΩsym::Matrix{Float64}: the matrix of Lsym eigenvectors.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.gplot-Tuple{SparseMatrixCSC{Float64, Int64}, Matrix{Float64}}","page":"Functions","title":"MultiscaleGraphSignalTransforms.gplot","text":"gplot(A, xyz; plotp = true,\n      style = :auto, width = 2, color = :blue,\n      shape = :none, mwidth = 2, mcolor = color, malpha = 1.0,\n      mscolor = color, mswidth = 1, msalpha = 1.0,\n      grid::Bool = false, label = \"\", subplot = 1)\n\nGPLOT Plot graph, as in graph theory. GPLOT(A,xyz,...) plots the graph specified by the adjacency matrix A and the node coordinates xyz. GPLOT!(A,xyz,...) adds a plot to current one.\n\nInput Arguments\n\nA::SparseMatrixCSC{Float64,Int}: the adjacency matrix of a graph G\nxyz::Matrix{Float64}: The coordinates array, xyz, is an n-by-2 or n-by-3 matrix\n\nwith the position for node i in the i-th row, xyz[i,:] = [x[i] y[i]] or xyz[i,:] = [x[i] y[i] z[i]].\n\nplotp::Bool: if the plot is made (default) or return the X, Y, Z arrays\nstyle::Symbol: of line; choose from Symbol[:auto,:solid,:dash,:dot,:dashdot] (default: :auto)\nwidth::Number: of line in pixels (default: 2; fraction, e.g., 0.5 is allowed)\ncolor::Symbol: of line; choose from Symbol[:white,:blue,:red,:green,...] (default: :blue)\nshape::Symbol: choose from Symbol[:none,:auto,:circle,:rect,:star5,:diamond,                                     :hexagon,:cross,:xcross,:utriangle,                                     :dtriangle,:pentagon,:heptagon,:octagon,                                     :star4,:star6,:star7,:star8,:vline,:hline] (default: :none)\nmwidth::Number: marker size (or radius) in pixels (default: 2)\nmcolor::Symbol: of marker (default: the same as line color)\nmalpha::Float64: opacity of marker interior; choose from [0,1] (default: 1.0)\nmswidth::Number: marker stroke size (width) in pixels (default: 1)\nmscolor::Symbol: of marker stroke (default: the same as line color)\nmsalpha::Float64: opacity of marker stroke; choose from [0,1] (default: 1.0)\ngrid::Bool: a flag to show grid lines (default: false)\nlabel::String: a string for legend (default: \"\")\nsubplot::Int: subplot index (default: 1)\n\nOutput Arguments\n\nX::Matrix{Float64}: Nan-punctuated X coordinate vector\nY::Matrix{Float64}: Nan-punctuated Y coordinate vector\nZ::Matrix{Float64}: Nan-punctuated Z coordinate vector\n\n(X,Y)= GPLOT(A,xyz,plotp=false,...) or (X,Y,Z) = GPLOT(A,xyz,plotp=false,...) return the NaN-punctuated vectors X and Y or X, Y and Z without actually generating a plot. These vectors can be used to generate the plot at a later time with PLOT or PLOT3D if desired.\n\nA backward-compatible elaboration of Mathworks's gplot that uses 3D data (if available) when the plot is rotated. Robert Piche, Tampere Univ. of Tech., 2005\n\nTranslated into julia by Naoki Saito, Dec. 21, 2016. Note that we should still consider the keywords organized as function gplot(A,xyz,kw...)\n\nNicholas Hausch edits: Must install Plots package For 3D rotation, use plotlyjs() backend\n\nRevised by Naoki Saito, Feb. 17, 2017 Revised by Naoki Saito, Oct. 13, 2017 Revised by Haotian Li, Jul. 25, 2018 Revised by Haotian Li and Naoki Saito for Julia v0.7/1.0, Sep. 21, 2018 Instead of plot(...), we decided to use Plots.plot(...) in order to avoid     the function name ambiguity; this is a safer approach. Revised by Naoki Saito, Oct. 22, 2018\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.heat_sol-NTuple{4, Any}","page":"Functions","title":"MultiscaleGraphSignalTransforms.heat_sol","text":"heat_sol(f0,ùöΩ,Œ£,t)\n\nHEAT_SOL gives the solution of heat partial differential equation with initial condition u(‚ãÖ, 0) = f0\n\nInput Arguments\n\nf0::Array{Float64}: initial condition vector.\nùöΩ::Matrix{Float64}: graph Laplacian eigenvectors, served as graph Fourier transform matrix\nŒ£::Array{Int}: diagonal matrix of eigenvalues.\nt::Float: time elapse.\n\nOutput Argument\n\nu::Array{Float64}: the solution vector at time t\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.ind_class-Tuple{Int64}","page":"Functions","title":"MultiscaleGraphSignalTransforms.ind_class","text":"T = ind_class(N::Int)\n\nGiven `N`, determine what class `ind` (and `rs`) should be\n\nInput Argument\n\nN::Int: the length of the graph signal\n\nOutput Argument\n\nT <: Unsigned: the unsigned integer class that ind should be\n\nCopyright 2015 The Regents of the University of California\n\nImplemented by Jeff Irion (Adviser: Dr. Naoki Saito) | Translated and revised by Naoki Saito, Feb. 8, 2017\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.levlist2levlengths!-Tuple{GraphPart, BasisSpec}","page":"Functions","title":"MultiscaleGraphSignalTransforms.levlist2levlengths!","text":"levlist2levlengths!(GP::GraphPart, BS::BasisSpec)\n\nCompute the levlengths info for a BasisSpec object\n\nInput Arguments\n\nGP::GraphPart: a GraphPart object\nBS::BasisSpec: BasisSpec object, without levlengths; after this function, the levlengths field is filled.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.lp_ngwp-Tuple{Matrix{Float64}, SparseMatrixCSC{Float64, Int64}, GraphPart}","page":"Functions","title":"MultiscaleGraphSignalTransforms.lp_ngwp","text":"lp_ngwp(ùöΩ::Matrix{Float64}, W_dual::SparseMatrixCSC{Float64, Int64},\n        GP_dual::GraphPart; œµ::Float64 = 0.3)\n\nconstruct the lapped NGWP and GP.tag in place.\n\nInput Arguments\n\nùöΩ::Matrix{Float64}: graph Laplacian eigenvectors\nW_dual::SparseMatrixCSC{Float64, Int64}: weight matrix of the dual graph\nGP_dual::GraphPart: GraphPart object of the dual graph\n\nOutput Argument\n\nwavelet_packet::Array{Float64,3}: the lapped NGWP dictionary. The first   index is for selecting wavelets at a fixed level; the second index is for   selecting the level j; the third index is for selecting elements in the   wavelet vector.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.lp_ngwp_analysis-Tuple{GraphSig, Matrix{Float64}, SparseMatrixCSC{Float64, Int64}, GraphPart}","page":"Functions","title":"MultiscaleGraphSignalTransforms.lp_ngwp_analysis","text":"lp_ngwp_analysis(G::GraphSig, ùöΩ::Matrix{Float64}, W_dual::SparseMatrixCSC{Float64, Int64},\n        GP_dual::GraphPart; œµ::Float64 = 0.3)\n\nperform the LP-NGWP transform of the graph signal(s) G.f.\n\nInput Arguments\n\nG::GraphSig: a GraphSig object\nùöΩ::Matrix{Float64}: graph Laplacian eigenvectors\nW_dual::SparseMatrixCSC{Float64, Int64}: weight matrix of the dual graph\nGP_dual::GraphPart: GraphPart object of the dual graph\n\nOutput Argument\n\nwavelet_packet::Array{Float64,3}: the lapped NGWP dictionary. The first   index is for selecting wavelets at a fixed level; the second index is for   selecting the level j; the third index is for selecting elements in the   wavelet vector.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.mgslp-Tuple{Matrix{Float64}}","page":"Functions","title":"MultiscaleGraphSignalTransforms.mgslp","text":"mgslp(A::Matrix{Float64}; tol::Float64 = 1e-12, p::Float64 = 1.0)\n\nModified Gram-Schmidt Process Orthogonalization with ‚Ñì·µñ pivoting algorithm (MGSLp)\n\nInput Arguments\n\nA::Matrix{Float64}: whose column vectors are to be orthogonalized.\n\nOutput Argument\n\nA::Matrix{Float64}: orthogonalization matrix of A's column vectors based on ‚Ñì·µñ pivoting.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.nat_spec_filter-Tuple{Any, Any}","page":"Functions","title":"MultiscaleGraphSignalTransforms.nat_spec_filter","text":"nat_spec_filter(l, D; œÉ = 0.25 * maximum(D), method = :regular, thres = 0.2)\n\nassemble the natural spectral graph filter centered at the l-th eigenvector via the distance matrix D.\n\nInput Arguments\n\nl::Int64: index of the centered eigenvector\nD::Matrix{Float64}: non-trivial distance matrix of the eigenvectors\nœÉ::Float64: Gaussian window width parameter (default: 0.25 * maximum(D))\nmethod::Symbol: :regular or :reduced (default: :regular)\nthres::Float64: cutoff threshold ‚àà (0, 1).\n\nOutput Argument\n\nùõç::Vector{Float64}: the natural spectral graph filter\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.natural_eigdist-Tuple{Any, Any, Any}","page":"Functions","title":"MultiscaleGraphSignalTransforms.natural_eigdist","text":"natural_eigdist(ùöΩ, ùõå, Q; Œ± = 1.0, T = :Inf,\n                input_format = :zero_measures, distance = :DAG,\n                edge_weight = 1, edge_length = 1)\n\ncompute natural distances between graph Laplacian eigenvectors.\n\nInput Arguments\n\nùöΩ::Matrix{Float64}: matrix of (weighted) graph Laplacian eigenvectors.\nùõå::Vector{Float64}: vector of eigenvalues.\nQ::Matrix{Float64}: unweighted incidence matrix of the graph.\nŒ±::Float64: ROT parameter. (default: 1.0)\nT::Any: TSD parameter, i.e., the stopping time T in K_functional (default: :Inf)\ninput_format::Symbol: options: :zero_measures, :pmf1 and :pmf2 (default: :zero_measures)\ndistance::Symbol: options: :ROT, :HAD, :DAG and :TSD (default: :DAG)\nedg_length::Any: vector of edge lengths (default: 1 represents unweighted graphs)\nedge_weight::Any: the weights vector, which stores the affinity weight of   each edge (default: 1 represents unweighted graphs).\n\nOutput Argument\n\ndis::Matrix{Float64}: the distance matrix, dis[i,j] = d(ùúô·µ¢‚Çã‚ÇÅ, ùúô‚±º‚Çã‚ÇÅ).\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.ngwf_all_vectors-Tuple{Any, Any}","page":"Functions","title":"MultiscaleGraphSignalTransforms.ngwf_all_vectors","text":"ngwf_all_vectors(D, ùöΩ; œÉ = 0.2 * maximum(D))\n\nassemble the whole NGWF dictionary.\n\nInput Arguments\n\nD::Matrix{Float64}: non-trivial distance matrix of the eigenvectors\nùöΩ::Matrix{Float64}: graph Laplacian eigenvectors\nœÉ::Float64: Gaussian window width parameter (default: 0.25 * maximum(D))\n\nOutput Argument\n\nùì§::Matrix{Float64}: the NGWF dictionary\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.ngwp_analysis-Tuple{GraphSig, Array{Float64, 3}}","page":"Functions","title":"MultiscaleGraphSignalTransforms.ngwp_analysis","text":"ngwp_analysis(G::GraphSig, wavelet_packet::Array{Float64,3})\n\nFor a GraphSig object G, generate the matrix of NGWP expansion coefficients.\n\nInput Arguments\n\nG::GraphSig: an input GraphSig object\nwavelet_packet::Array{Float64,3}: the varimax wavelets packet.\n\nOutput Argument\n\ndmatrix::Array{Float64,3}: the expansion coefficients matrix.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.ngwp_bestbasis-Tuple{Array{Float64, 3}, GraphPart}","page":"Functions","title":"MultiscaleGraphSignalTransforms.ngwp_bestbasis","text":"(dvec_ngwp, BS_ngwp) = ngwp_bestbasis(dmatrix::Array{Float64,3}, GP_star::GraphPart;\n                                      cfspec::Any = 1.0, flatten::Any = 1.0,\n                                      j_start::Int = 1, j_end::Int = size(dmatrix, 2),\n                                      useParent::Bool = true)\n\nSelect the best basis from the matrix of NGWP expansion coefficients.\n\nInput Arguments\n\ndmatrix::Array{Float64,3}: the matrix of expansion coefficients\nGP_star::GraphPart: an input GraphPart object of the dual graph\ncfspec::Any: the specification of cost functional to be used (default = 1.0,   i.e., 1-norm)\nflatten::Any: the method for flattening vector-valued data to scalar-valued   data (default = 1.0, i.e, 1-norm)\nuseParent::Bool: the flag to indicate if we update the selected best basis   subspace to the parent when parent and child have the same cost (default = false)\n\nOutput Arguments\n\ndvec_ngwp::Matrix{Float64}: the vector of expansion coefficients corresponding   to the NGWP best basis\nBS_ngwp::BasisSpec: a BasisSpec object which specifies the NGWP best basis\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.nonorth2relerror-Tuple{Vector{Float64}, Matrix{Float64}}","page":"Functions","title":"MultiscaleGraphSignalTransforms.nonorth2relerror","text":"function nonorth2relerror(nonorth::array{Float64,1},B::array{Float64,2})\n\nGiven a vector 'nonorth' of non-orthonormal expansion coefficients and the matrix 'B' such that B*nonorth is the original signal, return a vector of relative approximation errors when retaining the 1,2,...,N largest coefficients in magnitude.\n\nInput argument\n\nnonorth:    a vector of non-orthonormal expansion coefficients\nB:          the matrix whose such that B*nonorth is the original signal\n\nOutput argument\n\nrelerror:   a vector of relative approximation errors\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.orth2relerror-Tuple{Vector{Float64}}","page":"Functions","title":"MultiscaleGraphSignalTransforms.orth2relerror","text":"function orth2relerror(orth)\n\nGiven a vector 'orth' of orthonormal expansion coefficients, return a vector of relative approximation errors when retaining the 1,2,...,N largest coefficients in magnitude.\n\nInput argument\n\north:    a vector of orthonormal expansion coefficients\n\nOutput argument\n\nrelerror:   a vector of relative approximation errors\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.pairclustering-Tuple{Matrix{Float64}, GraphPart}","page":"Functions","title":"MultiscaleGraphSignalTransforms.pairclustering","text":"pairclustering(ùöΩ::Matrix{Float64}, GP_star::GraphPart)\n\nconstruct the GraphPart object of the primal graph via pair-clustering algorithm.\n\nInput Arguments\n\nùöΩ::Matrix{Float64}: graph Laplacian eigenvectors ùöΩ\nGP_star::GraphPart: GraphPart object of the dual graph\n\nOutput Argument\n\nGP::GraphPart: GraphPart object of the primal graph via pair-clustering\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.partition_fiedler-Tuple{SparseMatrixCSC{Float64, Int64}}","page":"Functions","title":"MultiscaleGraphSignalTransforms.partition_fiedler","text":"(pm,v) = partition_fiedler(W; method, v)\n\nPartition the vertices of a graph according to the Fiedler vector\n\nInput Arguments\n\nW::SparseMatrixCSC{Float64,Int}: the edge weight matrix\nmethod::Symbol: the parition method to be used (:L or :Lrw or else ...)\nv::Vector{Float64}: the Fiedler vector supplied if v is a null vector\n\nOutput Arguments\n\npm::Vector{Int}: a vector of 1's and -1's\nv::Vector{Float64}: the Fiedler vector used for graph partitioning\n\nCopyright 2015 The Regents of the University of California\n\nImplemented by Jeff Irion (Adviser: Dr. Naoki Saito) Translated and revised by Naoki Saito, Feb. 9, 2017\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.partition_fiedler_pm-Tuple{Vector{Float64}}","page":"Functions","title":"MultiscaleGraphSignalTransforms.partition_fiedler_pm","text":"(pm, v) = partition_fiedler_pm(v::Vector{Float64})\n\nPartition an input Graph based on the Fiedler vector `v`\n\nInput Argument\n\nv::Vector{Float64}: the input Fiedler vector\n\nOutput Arguments\n\npm::Vector{Int}: the partition info\nv::Vector{Float64}: the output Fiedler vector if requested\n\nCopyright 2015 The Regents of the University of California\n\nImplemented by Jeff Irion (Adviser: Dr. Naoki Saito) Translated and revised by Naoki Saito, Feb. 10, 2017\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.partition_fiedler_troubleshooting-Tuple{Vector{Int64}, Vector{Float64}, SparseMatrixCSC{Float64, Int64}, Float64}","page":"Functions","title":"MultiscaleGraphSignalTransforms.partition_fiedler_troubleshooting","text":"pm = partition_fiedler_troubleshooting(pm,v,W,val)\n\nTroubleshoot potential issues with the partitioning\n\nInput Arguments\n\npm::Vector{Int}: an input partition info (+1 or -1) of each node\nv::Vector{Float64}: the Fiedler vector of the graph\nW::SparseMatrixCSC{Float64,Int}: an input edge weight matrix\nval::Float64: the algebraic connectivity (i.e., lambda_2)\n\nOuput Arguments\n\npm::Vector{Int}: a final partition info vector\n\nCopyright 2015 The Regents of the University of California\n\nImplemented by Jeff Irion (Adviser: Dr. Naoki Saito) Translated and revised by Naoki Saito, Feb. 10, 2017\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.partition_fiedler_troubleshooting-Tuple{Vector{Int64}}","page":"Functions","title":"MultiscaleGraphSignalTransforms.partition_fiedler_troubleshooting","text":"pm = partition_fiedler_troubleshooting(pm)\n\nTroubleshoot potential issues with the partitioning\n\nInput Arguments\n\npm::Vector{Int}: an input partition info (+1 or -1) of each node\n\nOuput Arguments\n\npm::Vector{Int}: a final partition info vector\n\nCopyright 2015 The Regents of the University of California\n\nImplemented by Jeff Irion (Adviser: Dr. Naoki Saito) Translated and revised by Naoki Saito, Feb. 10, 2017\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.partition_pc-Tuple{Matrix{Float64}, Vector{Int64}, Vector{Int64}, Vector{Int64}}","page":"Functions","title":"MultiscaleGraphSignalTransforms.partition_pc","text":"partition_pc(ùöΩ::Matrix{Float64}, indrs::Vector{Int}, indrs_dual1::Vector{Int}, indrs_dual2::Vector{Int})\n\nbased on the partition on dual graph, partition the primal graph region (indexed by indrs) into two pieces via the pair-clustering algorithm.\n\nInput Arguments\n\nùöΩ::Matrix{Float64}: graph Laplacian eigenvectors ùöΩ\nindrs::Vector{Int}: indices of the primal graph region to be partitioned\nindrs_dual1::Vector{Int}: index1 of the dual graph region's partition result\nindrs_dual2::Vector{Int}: index2 of the dual graph region's partition result\n\nOutput Argument\n\nindp1::Vector{Int}: index1 of indrs for the partition result\nindp2::Vector{Int}: index2 of indrs for the partition result\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.pc_ngwp-Tuple{Matrix{Float64}, GraphPart, GraphPart}","page":"Functions","title":"MultiscaleGraphSignalTransforms.pc_ngwp","text":"pc_ngwp(ùöΩ::Matrix{Float64}, GP_star::GraphPart, GP::GraphPart)\n\nconstruct pair-clustering NGWP and GP.tag in place.\n\nInput Arguments\n\nùöΩ::Matrix{Float64}: graph Laplacian eigenvectors ùöΩ\nGP_star::GraphPart: GraphPart object of the dual graph\nGP::GraphPart: GraphPart object of the primal graph\n\nOutput Argument\n\nwavelet_packet::Array{Float64,3}: the pair-clustering NGWP. The first   index is for selecting wavelets at a fixed level; the second index is for   selecting the level j; the third index is for selecting elements in the   wavelet vector.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.rngwf_all_vectors-Tuple{Any, Any}","page":"Functions","title":"MultiscaleGraphSignalTransforms.rngwf_all_vectors","text":"rngwf_all_vectors(D, ùöΩ; œÉ = 0.2 * maximum(D), thres = 0.2)\n\nassemble the reduced NGWF (rNGWF) dictionary.\n\nInput Arguments\n\nD::Matrix{Float64}: non-trivial distance matrix of the eigenvectors\nùöΩ::Matrix{Float64}: graph Laplacian eigenvectors\nœÉ::Float64: Gaussian window width parameter (default: 0.25 * maximum(D))\nthres::Float64: cutoff threshold ‚àà (0, 1).\n\nOutput Argument\n\nùì§::Matrix{Float64}: the rNGWF dictionary\ndic_l2x::Dict: a dictionary to store the filtered locations by QR at the l-th   centered eigenvector\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.rngwf_lx-Tuple{Any}","page":"Functions","title":"MultiscaleGraphSignalTransforms.rngwf_lx","text":"rngwf_lx(dic_l2x)\n\nfind the sequential subindices of rNGWF vectors.\n\nInput Arguments\n\ndic_l2x::Dict: a dictionary to store the filtered locations by QR at the l-th   centered eigenvector\n\nOutput Argument\n\nŒì::Vector{Tuple{Int64,Int64}}: the sequential subindices of rNGWF vectors.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.rs_to_region-Tuple{Matrix{Int64}, Matrix{Int64}}","page":"Functions","title":"MultiscaleGraphSignalTransforms.rs_to_region","text":"function rs_to_region(rs::Matrix{Any}, tag::Matrix{Any})\n\nFrom the imformation of rs, tag from GP, compute the tag_r matrix, which have the same size of dmatrix (expansion coefficient matrix). Each element indicates the place of the coefficient in the expansion tree.\n\nInput Arguments\n\nrs::Matrix{Any}: rs from GP, showing information of the partition tree\ntag::Matrix{Any}: tag from GP, indicating coefficients tag\n\nOutput Arguments\n\ntag_r::Matrix{UInt64}: showing information of the partition tree, same size as dmatrix\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.scatter_gplot-Tuple{Any}","page":"Functions","title":"MultiscaleGraphSignalTransforms.scatter_gplot","text":"scatter_gplot(X; marker = nothing, ms = 4, plotOrder = :normal, c = :viridis, subplot = 1)\n\nSCATTER_GPLOT generates a scatter plot figure, which is for quick viewing of a graph signal. SCATTER_GPLOT!(X; ...) adds a plot to current one.\n\nInput Arguments\n\nX::Matrix{Float64}: points locations, can be 2-dim or 3-dim.\nmarker::Array{Float64}: default is nothing. Present different colors given   different signal value at each node.\nms::Array{Float64}: default is 4. Present different node sizes given   different signal value at each node.\nplotOrder::Symbol: default is normal. Optional choices :s2l or :l2s, i.e.,   plots from the smallest value of marker to the largest value or the other way around.\nc::Symbol: default is :viridis. Colors.\nsubgplot::Int: default is 1. The subplot index.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.sort_wavelets-Tuple{Any}","page":"Functions","title":"MultiscaleGraphSignalTransforms.sort_wavelets","text":"sort_wavelets(A; onlyByLoc = false)\n\nsort A's column wavelet vectors based on their focused nodes' indices. flip signs via the cross correlation.\n\nInput Arguments\n\nA::Matrix{Float64}: whose column vectors are wavelets.\n\nOutput Argument\n\nA::Matrix{Float64}: a matrix with sorted and sign flipped column.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.spectral_clustering-Tuple{Any, Any}","page":"Functions","title":"MultiscaleGraphSignalTransforms.spectral_clustering","text":"spectral_clustering(ùöΩ, M)\n\nSPECTRAL_CLUSTERING return M graph clusters, i.e., {V‚Çñ| k = 1,2,...,M}.\n\nInput Argument\n\nùöΩ::Matrix{Float64}: the matrix of graph Laplacian eigenvectors.\nM::Int: the number of graph clusters.\n\nOutput Argument\n\nclusters::Vector{Vector{Int}}: graph cluster indices.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.spike-Tuple{Any, Any}","page":"Functions","title":"MultiscaleGraphSignalTransforms.spike","text":"spike(i, N)\n\nSPIKE gives the N-dim spike vector with i-th element equals 1.\n\nInput Arguments\n\ni::Int: index for one.\nN::Int: dimension of the target spike vector.\n\nOutput Argument\n\nv::Array{Float64}: the N-dim spike vector with i-th element equals 1.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.standardize_eigenvectors!-Tuple{Matrix{Float64}}","page":"Functions","title":"MultiscaleGraphSignalTransforms.standardize_eigenvectors!","text":"standardize_eigenvectors!(ùöΩ::Matrix{Float64})\n\nstandardize the signs of the eigenvectors such that 1) the term with the largest magnitude is positive; 2) if the max == -min, then make sure the first non-zero entry of the eigenvector is positive.\n\nInput Arguments\n\nùöΩ::Matrix{Float64}: matrix of graph Laplacian eigenvectors\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.tag_class-Tuple{Int64}","page":"Functions","title":"MultiscaleGraphSignalTransforms.tag_class","text":"T = tag_class(jmax::Int)\n\nGiven jmax, determine what class tag should be.\n\nInput Argument\n\njmax::Int: the number of levels in the recursive partitioning (j = 1:jmax)\n\nOutput Argument\n\nT <: Unsigned: the unsigned integer class that tag should be\n\nCopyright 2015 The Regents of the University of California\n\nImplemented by Jeff Irion (Adviser: Dr. Naoki Saito) | Translated and revised by Naoki Saito, Feb. 8, 2017\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.transform2D-Tuple{Any}","page":"Functions","title":"MultiscaleGraphSignalTransforms.transform2D","text":"transform2D(X; s = 1, t = [0,0])\n\nTRANSFORM2D dilate each point of X by scale s and translate by 2D vector t.\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.varimax-Tuple{Any}","page":"Functions","title":"MultiscaleGraphSignalTransforms.varimax","text":"varimax(A; gamma = 1.0, minit = 20, maxit = 1000, reltol = 1e-12)\n\nVARIMAX perform varimax (or quartimax, equamax, parsimax) rotation to the column vectors of the input matrix.\n\nInput Arguments\n\nA::Matrix{Float64}: input matrix, whose column vectors are to be rotated. d, m = size(A).\ngamma::Float64: default is 1. gamma = 0, 1, m/2, and d(m - 1)/(d + m - 2), corresponding to quartimax, varimax, equamax, and parsimax.\nminit::Int: default is 20. Minimum number of iterations, in case of the stopping criteria fails initially.\nmaxit::Int: default is 1000. Maximum number of iterations.\nreltol::Float64: default is 1e-12. Relative tolerance for stopping criteria.\n\nOutput Argument\n\nB::Matrix{Float64}: output matrix, whose columns are already been rotated.\n\nImplemented by Haotian Li, Aug. 20, 2019\n\n\n\n\n\n","category":"method"},{"location":"functions/#MultiscaleGraphSignalTransforms.vm_ngwp-Tuple{Matrix{Float64}, GraphPart}","page":"Functions","title":"MultiscaleGraphSignalTransforms.vm_ngwp","text":"vm_ngwp(ùöΩ::Matrix{Float64}, GP_star::GraphPart)\n\nconstruct varimax NGWP and GP_star.tag in place.\n\nInput Arguments\n\nùöΩ::Matrix{Float64}: graph Laplacian eigenvectors ùöΩ\nGP_star::GraphPart: GraphPart object of the dual graph\n\nOutput Argument\n\nwavelet_packet::Array{Float64,3}: the varimax NGWP. The first index is for   selecting wavelets at a fixed level; the second index is for selecting the   level j; the third index is for selecting elements in the wavelet vector.\n\n\n\n\n\n","category":"method"},{"location":"#MultiscaleGraphSignalTransforms.jl","page":"Home","title":"MultiscaleGraphSignalTransforms.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MultiscaleGraphSignalTransforms.jl is a collection of tools for graph signal processing including HGLET, GHWT, eGHWT, NGWP, Lapped NGWP, and Lapped HGLET. Some of them were originally written in MATLAB by Jeff Irion, but we added more functionalities, e.g., eGHWT, NGWP, etc.","category":"page"},{"location":"#COPYRIGHT","page":"Home","title":"COPYRIGHT","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Copyright 2015-2021 The Regents of the University of California","category":"page"},{"location":"","page":"Home","title":"Home","text":"Implemented by Jeff Irion, Haotian Li, Naoki Saito, and Yiqun Shao","category":"page"},{"location":"#SETUP","page":"Home","title":"SETUP","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the MultiscaleGraphSignalTransforms.jl, run","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg; Pkg.add(\"MultiscaleGraphSignalTransforms\")\r\njulia> using MultiscaleGraphSignalTransforms","category":"page"},{"location":"#GETTING-STARTED","page":"Home","title":"GETTING STARTED","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently, you can run a set of very small tests via ] test MultiscaleGraphSignalTransforms; see the actual file test/runtest.jl for more details.","category":"page"},{"location":"#REFERENCES","page":"Home","title":"REFERENCES","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"J. Irion and N. Saito, Hierarchical graph Laplacian eigen transforms, Japan SIAM Letters, vol. 6, pp. 21-24, 2014.\nJ. Irion and N. Saito, The generalized Haar-Walsh transform, Proc. 2014 IEEE Statistical Signal Processing Workshop, pp. 488-491, 2014.\nJ. Irion and N. Saito, Applied and computational harmonic analysis on graphs and networks, Wavelets and Sparsity XVI, (M. Papadakis, V. K. Goyal, D. Van De Ville, eds.), Proc. SPIE 9597, Paper #95971F, Invited paper, 2015.\nJ. Irion, Multiscale Transforms for Signals on Graphs: Methods and Applications, Ph.D. dissertation, University of California, Davis, Dec. 2015.\nJ. Irion and N. Saito, Learning sparsity and structure of matrices with multiscale graph basis dictionaries, Proc. 2016 IEEE 26th International Workshop on Machine Learning for Signal Processing (MLSP), (A. Uncini, K. Diamantaras, F. A. N. Palmieri, and J. Larsen, eds.), 2016.\nJ. Irion and N. Saito, Efficient approximation and denoising of graph signals using the multiscale basis dictionaries, IEEE Transactions on Signal and Information Processing over Networks, Vol. 3, no. 3, pp. 607-616, 2017.\nY. Shao and N. Saito, The extended Generalized Haar-Walsh Transform and applications, Wavelets and Sparsity XVIII, (D. Van De Ville, M. Papadakis, and Y. M. Lu, eds.), Proc. SPIE 11138, Paper #111380C, 2019.\nY. Shao, The Extended Generalized Haar-Walsh Transform and Applications, Ph.D. dissertation, University of California, Davis, Sep. 2020.\nH. Li and N. Saito, Metrics of graph Laplacian eigenvectors, Wavelets and Sparsity XVIII, (D. Van De Ville, M. Papadakis, and Y. M. Lu, eds.), Proc. SPIE 11138, Paper #111381K, 2019.\nC. Alexander, H. Li and N. Saito, Natural graph wavelet packet dictionaries, J. Fourier Anal. Appl., vol. 27, Article #41, 2021.\nH. Li, Natural Graph Wavelet Dictionaries: Methods and Applications, Ph.D. dissertation, University of California, Davis, Jun. 2021.","category":"page"}]
}
