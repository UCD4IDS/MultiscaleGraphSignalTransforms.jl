<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions ¬∑ MultiscaleGraphSignalTransforms.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MultiscaleGraphSignalTransforms.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Functions</a><ul class="internal"><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/haotian127/MultiscaleGraphSignalTransforms.jl/blob/master/docs/src/functions.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.Bilinear_rendering-Tuple{Any, Any}" href="#MultiscaleGraphSignalTransforms.Bilinear_rendering-Tuple{Any, Any}"><code>MultiscaleGraphSignalTransforms.Bilinear_rendering</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Bilinear_rendering(X, Img_Mat)</code></pre><p>NN_RENDERING generates a rendering signal at each point of <code>X</code> from the image <code>Img_Mat</code> by bilinear interpolation method.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.GraphSig_Plot-Tuple{GraphSig}" href="#MultiscaleGraphSignalTransforms.GraphSig_Plot-Tuple{GraphSig}"><code>MultiscaleGraphSignalTransforms.GraphSig_Plot</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">GraphSig_Plot(G::GraphSig; symmetric::Bool = false,
  markersize::Float64 = 2.,
  markercolor::Symbol = :balance,
  markershape::Symbol = :circle,
  markerstrokewidth::Float64 = 1.0,
  markerstrokealpha::Float64 = 1.0,
  markervaluevaries::Bool = true,
  linewidth::Float64 = 1.,
  linecolor::Symbol = :blue,
  linestyle::Symbol = :solid,
  clim::Tuple{Float64,Float64} = (0., 0.),
  notitle::Bool = false, nocolorbar::Bool = false, nolegend::Bool = true,
  stemplot::Bool = false, sortnodes::Bool = false)</code></pre><p>Display a plot of the data in a GraphSig object</p><p><strong>Input Argument</strong></p><ul><li><code>G::GraphSig</code>:        an input GraphSig object</li><li><code>symmetric</code>           symmetrize the colorbar</li><li><code>markersize</code>          the size of the nodes</li><li><code>markercolor</code>         markercolor scheme</li><li><code>markershape</code>         shape of marker</li><li><code>markerstrokewidth</code>   width of marker stroke</li><li><code>markerstrokealpha</code>   capacity of marker stroke</li><li><code>markervaluevaries</code>   if the marker color depends on the signal value</li><li><code>linewidth</code>           the width of the lines in gplot</li><li><code>linecolor</code>           the color of the lines (1D) / graph edges (2D &amp; 3D)</li><li><code>linestyle</code>:          the style of line</li><li><code>notitle</code>             display a title</li><li><code>nocolorbar</code>          display a colorbar</li><li><code>nolegend</code>            display a legend</li><li><code>stemplot</code>            use a stem plot</li><li><code>clim</code>                specify the dynamic display range</li><li><code>sortnodes</code>           plot the signal values from smallest to largest in magnitude</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.HGLET_dictionary-Tuple{GraphPart, GraphSig}" href="#MultiscaleGraphSignalTransforms.HGLET_dictionary-Tuple{GraphPart, GraphSig}"><code>MultiscaleGraphSignalTransforms.HGLET_dictionary</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">HGLET_dictionary(GP::GraphPart, G::GraphSig; method::Symbol = :L)</code></pre><p>assemble the whole HGLET dictionary</p><p><strong>Input Arguments</strong></p><ul><li><code>GP</code>: a GraphPart object</li><li><code>G</code>:  a GraphSig object</li><li><code>method</code>: <code>:L</code> or <code>:Lsym</code></li></ul><p><strong>Output Argument</strong></p><ul><li><code>dictionary</code>: the HGLET dictionary</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.K_functional-Tuple{Vector{Float64}, Vector{Float64}, Matrix{Float64}, Matrix{Float64}, Vector{Float64}}" href="#MultiscaleGraphSignalTransforms.K_functional-Tuple{Vector{Float64}, Vector{Float64}, Matrix{Float64}, Matrix{Float64}, Vector{Float64}}"><code>MultiscaleGraphSignalTransforms.K_functional</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">K_functional(ùê©::Vector{Float64}, ùê™::Vector{Float64}, ùöΩ::Matrix{Float64},
             ‚àáùöΩ::Matrix{Float64}, ùõå::Vector{Float64}; length::Any = 1,
             T::Any = :Inf, dt::Float64 = 0.5/maximum(ùõå), tol::Float64 = 1e-5)</code></pre><p>computes the K_functional between two vector meassures ùê© and ùê™ on a graph.</p><p><strong>Input Argument</strong></p><ul><li><code>ùê©::Vector{Float64}</code>: the source vector measure.</li><li><code>ùê™::Vector{Float64}</code>: the destination vector measure.</li><li><code>ùöΩ::Matrix{Float64}</code>: matrix of the unweighted graph Laplacian eigenvectors.</li><li><code>‚àáùöΩ::Matrix{Float64}</code>: gradient of unweighted graph Laplacian eigenvectors.</li><li><code>ùõå::Vector{Float64}</code>: vector of eigenvalues.</li><li><code>length::Any</code>: vector of edge lengths (default: 1 represents unweighted graphs)</li><li><code>T::Any</code>: the stopping time T in K_functional (default: :Inf)</li><li><code>tol::Float64</code>: tolerance for convergence (default: 1e-5)</li></ul><p><strong>Output Argument</strong></p><ul><li><code>K::Float64</code>: TSD distance d_{TSD}(p, q; T).</li><li><code>E::Float64</code>: an estimated upper bound on the absolute error. In general,   <code>E &lt;= tol * norm(K)</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.LPHGLET_Analysis_All-Tuple{GraphSig, GraphPart}" href="#MultiscaleGraphSignalTransforms.LPHGLET_Analysis_All-Tuple{GraphSig, GraphPart}"><code>MultiscaleGraphSignalTransforms.LPHGLET_Analysis_All</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function LPHGLET_Analysis_All(G::GraphSig, GP::GraphPart; œµ::Float64 = 0.3)</code></pre><p>For a GraphSig object &#39;G&#39;, generate the 2 matrices of Lapped-HGLET expansion coefficients corresponding to the eigenvectors of L and Lsym</p><p><strong>Input Arguments</strong></p><ul><li><code>G</code>:  a GraphSig object</li><li><code>GP</code>: a GraphPart object</li><li><code>œµ</code>: relative action bandwidth (default: 0.3)</li></ul><p><strong>Output Argument</strong></p><ul><li><code>dmatrixlH</code>:        the matrix of expansion coefficients for L</li><li><code>dmatrixlHsym</code>:     the matrix of expansion coefficients for Lsym</li><li><code>GP</code>:              a GraphPart object</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.LPHGLET_Synthesis-Tuple{Matrix{Float64}, GraphPart, BasisSpec, GraphSig}" href="#MultiscaleGraphSignalTransforms.LPHGLET_Synthesis-Tuple{Matrix{Float64}, GraphPart, BasisSpec, GraphSig}"><code>MultiscaleGraphSignalTransforms.LPHGLET_Synthesis</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function LPHGLET_Synthesis(dvec::Vector{Float64}, GP::GraphPart, BS::BasisSpec, G::GraphSig; method::Symbol = :L, œµ::Float64 = 0.3)</code></pre><p>Perform Lapped-HGLET Synthesis transform</p><p><strong>Input Arguments</strong></p><ul><li><code>dvec</code>: the expansion coefficients corresponding to the chosen basis</li><li><code>GP</code>: a GraphPart object</li><li><code>BS</code>: a BasisSpec object</li><li><code>G</code>: a GraphSig object</li><li><code>method</code>: :L or :Lsym, indicating which eigenvectors are used</li><li><code>œµ</code>: relative action bandwidth (default: 0.3)</li></ul><p><strong>Output Argument</strong></p><ul><li><code>f</code>: the reconstructed signal</li><li><code>GS</code>: the reconstructed GraphSig object</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.LPHGLET_dictionary-Tuple{GraphPart, GraphSig}" href="#MultiscaleGraphSignalTransforms.LPHGLET_dictionary-Tuple{GraphPart, GraphSig}"><code>MultiscaleGraphSignalTransforms.LPHGLET_dictionary</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">LPHGLET_dictionary(GP::GraphPart, G::GraphSig; method::Symbol = :L, œµ::Float64 = 0.3)</code></pre><p>assemble the whole LP-HGLET dictionary</p><p><strong>Input Arguments</strong></p><ul><li><code>GP</code>: a GraphPart object</li><li><code>G</code>:  a GraphSig object</li><li><code>method</code>: <code>:L</code> or <code>:Lsym</code></li><li><code>œµ</code>: relative action bandwidth (default: 0.3)</li></ul><p><strong>Output Argument</strong></p><ul><li><code>dictionary</code>: the LP-HGLET dictionary</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.NGWP_jkl-Tuple{GraphPart, Int64, Int64}" href="#MultiscaleGraphSignalTransforms.NGWP_jkl-Tuple{GraphPart, Int64, Int64}"><code>MultiscaleGraphSignalTransforms.NGWP_jkl</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function NGWP_jkl(GP_star::GraphPart, drow::Int, dcol::Int)</code></pre><p>Generate the (j,k,l) indices for the NGWP basis vector corresponding to the coefficient dmatrix(drow,dcol)</p><p><strong>Input Arguments</strong></p><ul><li><code>GP_star::GraphPart</code>: a GraphPart object of the dual grpah</li><li><code>drow::Int</code>: the row of the expansion coefficient</li><li><code>dcol::Int</code>: the column of the expansion coefficient</li></ul><p><strong>Output Argument</strong></p><ul><li><code>j</code>: the level index of the expansion coefficient</li><li><code>k</code>: the subregion in dual graph&#39;s index of the expansion coefficient</li><li><code>l</code>: the tag of the expansion coefficient</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.NN_rendering-Tuple{Any, Any}" href="#MultiscaleGraphSignalTransforms.NN_rendering-Tuple{Any, Any}"><code>MultiscaleGraphSignalTransforms.NN_rendering</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NN_rendering(X, Img_Mat)</code></pre><p>NN_RENDERING generates a rendering signal at each point of <code>X</code> from the image <code>Img_Mat</code> by nearest neighbor method.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.ROT_Distance-Tuple{Any, Any, SparseMatrixCSC{Int64, Int64}}" href="#MultiscaleGraphSignalTransforms.ROT_Distance-Tuple{Any, Any, SparseMatrixCSC{Int64, Int64}}"><code>MultiscaleGraphSignalTransforms.ROT_Distance</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ROT_Distance(A, B, Q; edge_length = 1, Œ± = 1.0)</code></pre><p>computes the ROT distance matrix from A&#39;s column vectors to B&#39;s column vectors. If A, B are vector inputs, then it also returns the cost value and the optimal transport plan.</p><p><strong>Input Argument</strong></p><ul><li><code>A::Any</code>: a vector or matrix whose columns are initial probability measures.</li><li><code>B::Any</code>: a vector or matrix whose columns are terminal probability measures.</li><li><code>Q::SparseMatrixCSC{Int64,Int64}</code>: the unweighted incidence matrix of the graph.</li><li><code>edge_length::Any</code>: the length vector (default: <code>1</code> represents unweighted graphs)</li><li><code>Œ±::Float64</code>: default is <code>1.0</code>. ROT parameter.</li><li><code>retPlan::Bool</code>: an indicator if return the optimal plan (default: <code>false</code>)</li></ul><p><strong>Output Argument</strong></p><ul><li><code>dis::Matrix{Float64}</code>: distance matrix, dis[i,j] = d_{ROT}(a·µ¢, b‚±º; Œ±).</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.SunFlowerGraph-Tuple{}" href="#MultiscaleGraphSignalTransforms.SunFlowerGraph-Tuple{}"><code>MultiscaleGraphSignalTransforms.SunFlowerGraph</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SunFlowerGraph(; N = 400)</code></pre><p>SUNFLOWERGRAPH construct a simple weighted sunflower graph with N vertices. Edge weights are the reciprocal of Euclidean distances.</p><p><strong>Input Arguments</strong></p><ul><li><code>N::Int64</code>: default is 400, the number of vertices. Requires N &gt; 26.</li></ul><p><strong>Output Argument</strong></p><ul><li><code>G::SimpleWeightedGraph{Int64,Float64}</code>: a simple weighted graph of the sunflower.</li><li><code>L::Matrix{Float64}</code>: the weighted unnormalized graph Laplacian matrix.</li><li><code>X::Matrix{Float64}</code>: a matrix whose i-th row represent the 2D coordinates of the i-th node.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.alternating_numbers-Tuple{Any}" href="#MultiscaleGraphSignalTransforms.alternating_numbers-Tuple{Any}"><code>MultiscaleGraphSignalTransforms.alternating_numbers</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">alternating_numbers(n)</code></pre><p>ALTERNATING_NUMBERS e.g., n = 5, returns [1,5,2,4,3]; n = 6, returns [1,6,2,5,3,4]</p><p><strong>Input Arguments</strong></p><ul><li><code>n::Int64</code>: number of nodes in x-axis.</li></ul><p><strong>Output Argument</strong></p><ul><li><code>arr::Array{Int64}</code>: result array.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.approx_error_plot-Tuple{Vector{Vector{Float64}}}" href="#MultiscaleGraphSignalTransforms.approx_error_plot-Tuple{Vector{Vector{Float64}}}"><code>MultiscaleGraphSignalTransforms.approx_error_plot</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">approx_error_plot(DVEC::Vector{Vector{Float64}}; frac::Float64 = 0.50)</code></pre><p>draw relative approx. error w.r.t. fraction of coefficients retained (FCR)</p><p><strong>Input Arguments</strong></p><ul><li><code>DVEC::Vector{Vector{Float64}}</code>: a list of expansion coefficients.</li><li><code>fraction::Float64</code>: default is 0.5.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.approx_error_plot2-Tuple{Vector{Vector{Float64}}}" href="#MultiscaleGraphSignalTransforms.approx_error_plot2-Tuple{Vector{Vector{Float64}}}"><code>MultiscaleGraphSignalTransforms.approx_error_plot2</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">approx_error_plot2(DVEC::Vector{Vector{Float64}}; frac::Float64 = 0.50)</code></pre><p>draw relative approx. error w.r.t. fraction of coefficients retained (FCR) in dissertation</p><p><strong>Input Arguments</strong></p><ul><li><code>DVEC::Vector{Vector{Float64}}</code>: a list of expansion coefficients.</li><li><code>fraction::Float64</code>: default is 0.5.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.bs_level-Tuple{GraphPart, Int64}" href="#MultiscaleGraphSignalTransforms.bs_level-Tuple{GraphPart, Int64}"><code>MultiscaleGraphSignalTransforms.bs_level</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BS = bs_level(GP::GraphPart, j::Int, c2f::Bool = true)</code></pre><p>Specify the basis corresponding to level j for a given graph partitioning</p><p><strong>Input Arguments</strong></p><ul><li><code>GP::GraphPart</code>: an input GraphPart object</li><li><code>j::Int</code>: the level to which the basis corresponds (<code>j = 0</code> is the global level)</li><li><code>c2f::Bool</code>: a flag for c2f or f2c (default: true, i.e., c2f)</li></ul><p><strong>Output Argument</strong></p><ul><li><code>BS::BasisSpec</code>: a BasisSpec object corresponding to the level <code>j</code> basis</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.bs_walsh-Tuple{GraphPart}" href="#MultiscaleGraphSignalTransforms.bs_walsh-Tuple{GraphPart}"><code>MultiscaleGraphSignalTransforms.bs_walsh</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BS = bs_walsh(GP::GraphPart)</code></pre><p>Specify the walsh basis corresponding to for a given graph partitioning</p><p><strong>Input Arguments</strong></p><ul><li><code>GP::GraphPart</code>: an input GraphPart object</li></ul><p><strong>Output Argument</strong></p><ul><li><code>BS::BasisSpec</code>: a BasisSpec object corresponding to the walsh basis</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.bsfull-Tuple{GraphPart, BasisSpec}" href="#MultiscaleGraphSignalTransforms.bsfull-Tuple{GraphPart, BasisSpec}"><code>MultiscaleGraphSignalTransforms.bsfull</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(levlistfull, levlengthsfull, transfull) = bsfull(GP::GraphPart, BS::BasisSpec, trans::Vector{Bool})</code></pre><p>Given a BasisSpec object, return the full-length, redundant levlist, levlengths, and trans descriptions.</p><p><strong>Input Arguments</strong></p><ul><li><code>GP::GraphPart</code>: an input GraphPart object</li><li><code>BS::BasisSpec</code>: an input BasisSpec object</li><li><code>trans::Vector{Bool}</code>: a specification of the transforms used for the HGLET-GHWT hybrid transform (default: null)</li><li><code>levlengthsp::Bool</code>: a flag to return levlengthsfull (default: false)</li><li><code>transp::Bool</code>: a flag to return transfull (default: false)</li></ul><p><strong>Output Arguments</strong></p><ul><li><code>levlistfull::Vector{UInt8}</code>: the full-length, redundant levels list description</li><li><code>levlengthsfull::Vector{UInt8}</code>: the full-length, redundant levels lengths description</li><li><code>transfull::Matrix{Bool}</code>: the full-length, redundant trans description</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.cat_plot-Tuple{Any}" href="#MultiscaleGraphSignalTransforms.cat_plot-Tuple{Any}"><code>MultiscaleGraphSignalTransforms.cat_plot</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cat_plot(X; marker = nothing, ms = 4)</code></pre><p>CAT_PLOT generates a scatter plot figure for cat example, which is for quick viewing of a graph signal within a specific range (i.e., xlims, ylims, zlims). CAT_PLOT!(X; ...) adds a plot to <code>current</code> one.</p><p><strong>Input Arguments</strong></p><ul><li><code>X::Matrix{Float64}</code>: 3-dim points.</li><li><code>marker::Array{Float64}</code>: default is nothing. Present different colors given   different signal value at each node.</li><li><code>ms::Array{Float64}</code>: default is 4. Present different node sizes given   different signal value at each node.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.characteristic-Tuple{Any, Any}" href="#MultiscaleGraphSignalTransforms.characteristic-Tuple{Any, Any}"><code>MultiscaleGraphSignalTransforms.characteristic</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">characteristic(list, N)</code></pre><p>CHARACTERISTIC gives the characteristic function in n-dim vector space with     values of index in list equal to 1.</p><p><strong>Input Arguments</strong></p><ul><li><code>list::Array{Int}</code>: list of indices.</li><li><code>N::Int</code>: dimension of the target vector.</li></ul><p><strong>Output Argument</strong></p><ul><li><code>v::Array{Float64}</code>: the n-dim characteristic vector with values of index in list equal to 1.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.compute_SNR-Tuple{Any, Any}" href="#MultiscaleGraphSignalTransforms.compute_SNR-Tuple{Any, Any}"><code>MultiscaleGraphSignalTransforms.compute_SNR</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_SNR(f, g)</code></pre><p>COMPUTE_SNR, g = f + œµ, SNR = 20 * log10(norm(f)/norm(g-f)).</p><p><strong>Input Arguments</strong></p><ul><li><code>f::Array{Float64}</code>: original signal.</li><li><code>g::Array{Float64}</code>: noisy signal.</li></ul><p><strong>Output Argument</strong></p><ul><li><code>SNR::Float64</code>: SNR value.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.const_proj_wavelets-Tuple{Any, Any, Any}" href="#MultiscaleGraphSignalTransforms.const_proj_wavelets-Tuple{Any, Any, Any}"><code>MultiscaleGraphSignalTransforms.const_proj_wavelets</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">const_proj_wavelets(ùöΩ,vlist,elist; method = &quot;Modified Gram-Schmidt with Lp Pivoting&quot;)</code></pre><p>construct projection wavelets, i.e., project Œ¥ ‚àà vlist onto span({œÜ‚±º| j ‚àà elist}).</p><p><strong>Input Arguments</strong></p><ul><li><code>ùöΩ::Matrix{Float64}</code>: graph Laplacian eigenvectors ùöΩ</li><li><code>vlist::Array{Int}</code>: the list of considered node indices.</li><li><code>elist::Array{Int}</code>: the list of considered eigenvector indices.</li><li><code>method::Symbol</code>: default is <code>:MGSLp</code>. other options: <code>:IP</code> (Iterative-Projection),   <code>GS</code> (Gram Schmidt).</li></ul><p><strong>Output Argument</strong></p><ul><li><code>Wav::Matrix{Float64}</code>: a matrix whose columns are projected wavelet vectors.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.cost_functional-Tuple{Any}" href="#MultiscaleGraphSignalTransforms.cost_functional-Tuple{Any}"><code>MultiscaleGraphSignalTransforms.cost_functional</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">costfun = cost_functional(cfspec::Any)</code></pre><p>Determine the cost functional to be used by the best-basis algorithm.</p><p><strong>Input Argument</strong></p><ul><li><code>cfspec::Any</code>: the specification for the cost functional</li></ul><p><strong>Output Argument</strong></p><ul><li><code>costfun::Function</code>: the cost functional (as a function_handle)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.dct1d-Tuple{Any, Any}" href="#MultiscaleGraphSignalTransforms.dct1d-Tuple{Any, Any}"><code>MultiscaleGraphSignalTransforms.dct1d</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dct1d(k, N)</code></pre><p>DCT1D returns k-th 1D DCT basis vector in R·¥∫.</p><p><strong>Input Arguments</strong></p><ul><li><code>k::Int64</code>: ord of DCT basis vector. k = 1,2,...,N.</li><li><code>N::Int64</code>: vector dimension.</li></ul><p><strong>Output Argument</strong></p><ul><li><code>œÜ::Array{Float64}</code>: k-th 1D DCT basis vector in R·¥∫. (k is 1-indexed)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.dct2d_basis-Tuple{Any, Any}" href="#MultiscaleGraphSignalTransforms.dct2d_basis-Tuple{Any, Any}"><code>MultiscaleGraphSignalTransforms.dct2d_basis</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dct2d_basis(N1, N2)</code></pre><p>DCT2D_BASIS returns 2D DCT basis vectors in [0,1] x [0,1] with N1-1 and N2-1 subintervals respectively.</p><p><strong>Input Arguments</strong></p><ul><li><code>N1::Int64</code>: number of nodes in x-axis.</li><li><code>N2::Int64</code>: number of nodes in y-axis.</li></ul><p><strong>Output Argument</strong></p><ul><li><code>ùöΩ::Matrix{Float64}</code>: 2D DCT basis vectors.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.dmatrix2dvec-Tuple{Array{Float64, 3}, GraphPart, BasisSpec}" href="#MultiscaleGraphSignalTransforms.dmatrix2dvec-Tuple{Array{Float64, 3}, GraphPart, BasisSpec}"><code>MultiscaleGraphSignalTransforms.dmatrix2dvec</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dvec = dmatrix2dvec(dmatrix::Array{Float64,3}, GP::GraphPart, BS::BasisSpec)</code></pre><p>Given a matrix of expansion coefficients, convert it to a vector. This function assumes that the input coefficient array <code>dmatrix</code> is in the coarse-to-fine format. If <code>BS.c2f == false</code>, then this function internally converts <code>dmatrix</code> into the fine-to-coarse format. Hence, if one supplies the f2c <code>dmatrix</code>, the results become wrong, and the subsequent procedure may result in error.</p><p><strong>Input Arguments</strong></p><ul><li><code>dmatrix::Array{Float64,3}</code>: matrices of expansion coefficients</li><li><code>GP::GraphPart</code>: an input GraphPart object</li><li><code>BS::BasisSpec</code>: an input BasisSpec object</li></ul><p><strong>Outputs Arguments</strong></p><ul><li><code>dvec::Matrix{Float64}</code>: a vector of expansion coefficients</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.dmatrix2dvec-Tuple{Array{Float64, 3}, GraphPart}" href="#MultiscaleGraphSignalTransforms.dmatrix2dvec-Tuple{Array{Float64, 3}, GraphPart}"><code>MultiscaleGraphSignalTransforms.dmatrix2dvec</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(dvec, BS) = dmatrix2dvec(dmatrix::Array{Float64,3}, GP::GraphPart)</code></pre><p>Given a matrix of expansion coefficients, convert it to a vector.</p><p><strong>Input Arguments</strong></p><ul><li><code>dmatrix::Array{Float64,3}</code>: matrices of expansion coefficients</li><li><code>GP::GraphPart</code>: an input GraphPart object</li><li><code>BS::BasisSpec</code>: an input BasisSpec object</li></ul><p><strong>Outputs Arguments</strong></p><ul><li><code>dvec::Matrix{Float64}</code>: a vector of expansion coefficients</li><li><code>BS::BasisSpec</code>: an output BasisSpec object</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.dmatrix_flatten-Tuple{Array{Float64, 3}, Any}" href="#MultiscaleGraphSignalTransforms.dmatrix_flatten-Tuple{Array{Float64, 3}, Any}"><code>MultiscaleGraphSignalTransforms.dmatrix_flatten</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dmatrix_flatten(dmatrix::Array{Float64,3}, flatten::Any)</code></pre><p>Flatten dmatrix using the method specified by the string &quot;flatten&quot;</p><p><strong>Input Arguments</strong></p><ul><li><code>dmatrix::Array{Float64,3}</code>: the matrix of expansion coefficients; after this function is called, it becomes the size of (~, ~, 1).</li><li><code>flatten::Any</code>: the method for flattening dmatrix (see the code in details)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.dualgraph-Tuple{Matrix{Float64}}" href="#MultiscaleGraphSignalTransforms.dualgraph-Tuple{Matrix{Float64}}"><code>MultiscaleGraphSignalTransforms.dualgraph</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dualgraph(dist::Matrix{Float64}; method::Symbol = :inverse, œÉ::Float64 = 1.0)</code></pre><p>build the dual graph&#39;s weight matrix based on the given non-trivial eigenvector metric.</p><p><strong>Input Arguments</strong></p><ul><li><code>dist::Matrix{Float64}</code>: eigenvector distance matrix</li><li><code>method::Symbol</code>: default is by taking inverse of the distance between   eigenvectors. Ways to build the dual graph edge weights. Option: <code>:inverse</code>,   <code>:gaussian</code>.</li><li><code>œÉ::Float64</code>: default is <code>1.0</code>. Gaussian variance parameter.</li></ul><p><strong>Output Argument</strong></p><ul><li><code>G_star::GraphSig</code>: A <code>GraphSig</code> object containing the weight matrix of the   dual graph.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.dvec2dmatrix-Tuple{Matrix{Float64}, GraphPart, BasisSpec}" href="#MultiscaleGraphSignalTransforms.dvec2dmatrix-Tuple{Matrix{Float64}, GraphPart, BasisSpec}"><code>MultiscaleGraphSignalTransforms.dvec2dmatrix</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dmatrix = dvec2dmatrix(dvec::Matrix{Float64}, GP::GraphPart, BS::BasisSpec)</code></pre><p>Given a vector of expansion coefficients, convert it to a matrix.</p><p><strong>Input Arguments</strong></p><ul><li><code>dvec::Matrix{Float64}</code>: a vector of expansion coefficients</li><li><code>GP::GraphPart</code>: a GraphPart object</li><li><code>BS::BasisSpec</code>: a BasisSpec object</li></ul><p><strong>Output Argument</strong></p><ul><li><code>dmatrix::Array{Float64,3}</code>: a set of matrices of expansion coefficients</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.dvec_Threshold-Tuple{Matrix{Float64}, String, Float64, GraphPart, BasisSpec}" href="#MultiscaleGraphSignalTransforms.dvec_Threshold-Tuple{Matrix{Float64}, String, Float64, GraphPart, BasisSpec}"><code>MultiscaleGraphSignalTransforms.dvec_Threshold</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>function dvec_Threshold(dvec::Array{Float64}, SORH::String, keep::Float64,                 GP::GraphPart, BS::BasisSpec)</p><p>Threshold HGLET / GHWT coefficients</p><p><strong>Input Arguments</strong></p><ul><li><code>dvec::Array{Float64,2}</code>        the vector of expansion coefficients</li><li><code>SORH::String</code>        use soft (&#39;s&#39;) or hard (&#39;h&#39;) thresholding</li><li><code>keep::Float64</code>        a fraction between 0 and 1 which says how many coefficients should be kept</li><li><code>GP::GraphPart</code>          a GraphPart object, used to identify scaling coefficients</li><li><code>BS::BasisSpec</code>          a BasisSpec object, used to identify scaling coefficients</li></ul><p><strong>Output Argument</strong></p><ul><li><code>dvec_new::Vector{Float64}</code>        the thresholded expansion coefficients</li><li><code>kept::Float64</code>        the number of coefficients kept</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.eigDAG_Distance-Tuple{Any, Any, Any}" href="#MultiscaleGraphSignalTransforms.eigDAG_Distance-Tuple{Any, Any, Any}"><code>MultiscaleGraphSignalTransforms.eigDAG_Distance</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eigDAG_Distance(ùöΩ, Q, numEigs; edge_weights = 1)</code></pre><p>compute DAG distances between pairwise graph Laplacian eigenvectors.</p><p><strong>Input Arguments</strong></p><ul><li><code>ùöΩ::Matrix{Float64}</code>: matrix of graph Laplacian eigenvectors, ùúô‚±º‚Çã‚ÇÅ (j = 1,...,size(ùöΩ,1)).</li><li><code>Q::Matrix{Float64}</code>: incidence matrix of the graph.</li><li><code>numEigs::Int64</code>: number of eigenvectors considered.</li><li><code>edge_weight::Any</code>: default value is 1, stands for unweighted graph   (i.e., all edge weights equal to 1). For weighted graph, edge_weight is the   weights vector, which stores the affinity weight of each edge.</li></ul><p><strong>Output Argument</strong></p><ul><li><code>dis::Matrix{Float64}</code>: a numEigs x numEigs distance matrix, dis[i,j] = d_DAG(ùúô·µ¢‚Çã‚ÇÅ, ùúô‚±º‚Çã‚ÇÅ).</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.eigHAD_Affinity-Tuple{Any, Any}" href="#MultiscaleGraphSignalTransforms.eigHAD_Affinity-Tuple{Any, Any}"><code>MultiscaleGraphSignalTransforms.eigHAD_Affinity</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eigHAD_Affinity(ùöΩ, ùõå; indexEigs = 1:size(ùöΩ,2))</code></pre><p>EIGHAD_AFFINITY compute Hadamard (HAD) affinity between pairwise graph Laplacian eigenvectors.</p><p><strong>Input Arguments</strong></p><ul><li><code>ùöΩ::Matrix{Float64}</code>: matrix of graph Laplacian eigenvectors, ùúô‚±º‚Çã‚ÇÅ (j = 1,...,size(ùöΩ,1)).</li><li><code>ùõå::Array{Float64}</code>: array of eigenvalues. (ascending order)</li><li><code>indexEigs::Int</code>: default is all eigenvectors, indices of eigenvectors considered.</li></ul><p><strong>Output Argument</strong></p><ul><li><code>A::Matrix{Float64}</code>: a numEigs x numEigs affinity matrix, A[i,j] = a_HAD(ùúô·µ¢‚Çã‚ÇÅ, ùúô‚±º‚Çã‚ÇÅ).</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.eigHAD_Distance-Tuple{Any, Any}" href="#MultiscaleGraphSignalTransforms.eigHAD_Distance-Tuple{Any, Any}"><code>MultiscaleGraphSignalTransforms.eigHAD_Distance</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eigHAD_Distance(ùöΩ, ùõå; indexEigs = 1:size(ùöΩ,2))</code></pre><p>compute HAD &quot;distance&quot; (not really a distance) between pairwise graph Laplacian eigenvectors, i.e., d<em>HAD(ùúô·µ¢‚Çã‚ÇÅ, ùúô‚±º‚Çã‚ÇÅ) = ‚àö(1 - a</em>HAD(ùúô·µ¢‚Çã‚ÇÅ, ùúô‚±º‚Çã‚ÇÅ)¬≤).</p><p><strong>Input Arguments</strong></p><ul><li><code>ùöΩ::Matrix{Float64}</code>: matrix of graph Laplacian eigenvectors, ùúô‚±º‚Çã‚ÇÅ (j = 1,...,size(ùöΩ,1)).</li><li><code>ùõå::Array{Float64}</code>: array of eigenvalues. (ascending order)</li><li><code>indexEigs::Int</code>: default is all eigenvectors, indices of eigenvectors considered.</li></ul><p><strong>Output Argument</strong></p><ul><li><code>dis::Matrix{Float64}</code>: the HAD distance matrix, dis[i,j] = d_HAD(ùúô·µ¢‚Çã‚ÇÅ, ùúô‚±º‚Çã‚ÇÅ).</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.eigROT_Distance-Tuple{Matrix{Float64}, SparseMatrixCSC{Int64, Int64}}" href="#MultiscaleGraphSignalTransforms.eigROT_Distance-Tuple{Matrix{Float64}, SparseMatrixCSC{Int64, Int64}}"><code>MultiscaleGraphSignalTransforms.eigROT_Distance</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eigROT_Distance(P, Q; edge_length = 1, Œ± = 1.0)</code></pre><p>computes the ROT distance matrix of P&#39;s column vectors on a graph.</p><p><strong>Input Argument</strong></p><ul><li><code>P::Matrix{Float64}</code>: a matrix whose columns are vector measures with the same total mass.</li><li><code>Q::SparseMatrixCSC{Int64,Int64}</code>: the unweighted incidence matrix of the graph.</li><li><code>edge_length::Any</code>: the length vector (default: 1 represents unweighted graphs)</li><li><code>Œ±::Float64</code>: default is 1.0. ROT parameter.</li></ul><p><strong>Output Argument</strong></p><ul><li><code>dis::Matrix{Float64}</code>: distance matrix, dis[i,j] = d_{ROT}(p·µ¢, p‚±º; Œ±).</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.eigTSD_Distance-Tuple{Matrix{Float64}, Matrix{Float64}, Vector{Float64}, SparseMatrixCSC{Int64, Int64}}" href="#MultiscaleGraphSignalTransforms.eigTSD_Distance-Tuple{Matrix{Float64}, Matrix{Float64}, Vector{Float64}, SparseMatrixCSC{Int64, Int64}}"><code>MultiscaleGraphSignalTransforms.eigTSD_Distance</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eigTSD_Distance(P::Matrix{Float64}, ùöΩ::Matrix{Float64}, ùõå::Vector{Float64},
                Q::SparseMatrixCSC{Int64,Int64}; length::Any = 1,
                T::Any = :Inf, tol::Float64 = 1e-5)</code></pre><p>computes the TSD distance matrix of P&#39;s column vectors on a graph.</p><p><strong>Input Argument</strong></p><ul><li><code>P::Matrix{Float64}</code>: vector measures with the same total mass 0.</li><li><code>ùöΩ::Matrix{Float64}</code>: matrix of the unweighted graph Laplacian eigenvectors.</li><li><code>ùõå::Vector{Float64}</code>: vector of eigenvalues.</li><li><code>Q::SparseMatrixCSC{Int64,Int64}</code>: the unweighted incidence matrix.</li><li><code>length::Any</code>: vector of edge lengths (default: <code>1</code> represents unweighted graphs)</li><li><code>T::Any</code>: the stopping time T in K_functional (default: <code>:Inf</code>)</li><li><code>tol::Float64</code>: tolerance for integral convergence (default: <code>1e-5</code>)</li></ul><p><strong>Output Argument</strong></p><ul><li><code>dis::Matrix{Float64}</code>: distance matrix, d_{TSD}(œÜ·µ¢, œÜ‚±º; T).</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.eigsROT_Distance-Tuple{Matrix{Float64}, SparseMatrixCSC{Float64, Int64}, Matrix{Float64}}" href="#MultiscaleGraphSignalTransforms.eigsROT_Distance-Tuple{Matrix{Float64}, SparseMatrixCSC{Float64, Int64}, Matrix{Float64}}"><code>MultiscaleGraphSignalTransforms.eigsROT_Distance</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eigsROT_Distance(P::Matrix{Float64}, W::SparseMatrixCSC{Float64, Int64}, X::Matrix{Float64}; Œ±::Float64 = 1.0)</code></pre><p>computes the sROT distance matrix of P&#39;s column vectors on a (unweighted) tree.</p><p><strong>Input Argument</strong></p><ul><li><code>P::Matrix{Float64}</code>: a matrix whose columns are vector measures with the same total mass.</li><li><code>W::SparseMatrixCSC{Float64, Int64}</code>: the weight matrix of the tree.</li><li><code>X::Matrix{Float64}</code>: the node positions (i-th row represents node <code>i</code>&#39;s location)</li><li><code>Œ±::Float64</code>: default is 1.0. ROT parameter.</li></ul><p><strong>Output Argument</strong></p><ul><li><code>dist_sROT::Matrix{Float64}</code>: distance matrix, dist<em>sROT[i,j] = d</em>{sROT}(p·µ¢, p‚±º; Œ±).</li><li><code>Ws::SparseMatrixCSC{Float64, Int64}</code>: the weight matrix of the simplified tree.</li><li><code>Xs::Matrix{Float64}</code>: the node locations of the simplified tree</li><li><code>ùöØ::Matrix{Float64}</code>: the shortened pmfs from <code>P</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.find_subgraph_inds-Tuple{SparseMatrixCSC{Float64, Int64}}" href="#MultiscaleGraphSignalTransforms.find_subgraph_inds-Tuple{SparseMatrixCSC{Float64, Int64}}"><code>MultiscaleGraphSignalTransforms.find_subgraph_inds</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_subgraph_inds(Wc::SparseMatrixCSC{Float64, Int64})</code></pre><p>find all subgraph indices of a tree. (subgraph includes: branches and junctions)</p><p><strong>Input Argument</strong></p><ul><li><code>Wc::SparseMatrixCSC{Float64, Int64}</code>: the weight matrix of the tree chopped by   the junctions.</li></ul><p><strong>Output Argument</strong></p><ul><li><code>Ind::Matrix{Float64}</code>: a matrix whose columns represent the subgraph node   indices in binary form.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.findminimum-Tuple{Any, Any}" href="#MultiscaleGraphSignalTransforms.findminimum-Tuple{Any, Any}"><code>MultiscaleGraphSignalTransforms.findminimum</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findminimum(v, n)</code></pre><p>FINDMINIMUM finds the first n smallest elements&#39; indices.</p><p><strong>Input Arguments</strong></p><ul><li><code>v::Array{Float64}</code>: the candidate values for selection.</li><li><code>n::Int</code>: number of smallest elements for consideration.</li></ul><p><strong>Output Argument</strong></p><ul><li><code>idx::Array{Int}</code>: n smallest elements&#39; indices.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.frame_approx-Tuple{Any, Any, Any}" href="#MultiscaleGraphSignalTransforms.frame_approx-Tuple{Any, Any, Any}"><code>MultiscaleGraphSignalTransforms.frame_approx</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">frame_approx(f, U, V; num_kept = length(f))</code></pre><p>approximate signal <code>f</code> by the frame <code>U</code>.</p><p><strong>Input Arguments</strong></p><ul><li><code>f::Vector{Float64}</code>: input graph signal</li><li><code>U::Matrix{Float64}</code>: a frame operator (matrix or dictionary)</li><li><code>V::Matrix{Float64}</code>: the dual frame operator of <code>U</code></li><li><code>num_kept::Int64</code>: number of kept coefficients (NCR)</li></ul><p><strong>Output Argument</strong></p><ul><li><code>rel_error::Vector{Float64}</code>: the relative errors</li><li><code>f_approx::Vector{Float64}</code>: the approximated signal</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.freq_band_matrix-Tuple{Any, Any}" href="#MultiscaleGraphSignalTransforms.freq_band_matrix-Tuple{Any, Any}"><code>MultiscaleGraphSignalTransforms.freq_band_matrix</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">freq_band_matrix(ls,n)</code></pre><p>FREQ_BAND_MATRIX provides characteristic diagonal matrix, which is useful for spectral graph filters design.</p><p><strong>Input Arguments</strong></p><ul><li><code>ls::Array{Int}</code>: list of indices.</li><li><code>n::Int</code>: dimension of the target vector.</li></ul><p><strong>Output Argument</strong></p><ul><li><code>D::Array{Float64}</code>: the zero/one diagonal matrix.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.getall_expansioncoeffs-Tuple{GraphSig, GraphPart, Array{Float64, 3}, Array{Float64, 3}, Matrix{Float64}}" href="#MultiscaleGraphSignalTransforms.getall_expansioncoeffs-Tuple{GraphSig, GraphPart, Array{Float64, 3}, Array{Float64, 3}, Matrix{Float64}}"><code>MultiscaleGraphSignalTransforms.getall_expansioncoeffs</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getall_expansioncoeffs(G_Sig::GraphSig, GP_star::GraphPart, VM_NGWP::Array{Float64,3}, PC_NGWP::Array{Float64,3}, ùöΩ::Matrix{Float64})</code></pre><p>get all expansion coefficients of <code>f</code> via all methods in NGWP.jl and MTSG.jl</p><p><strong>Input Arguments</strong></p><ul><li><code>G_Sig::GraphSig</code>: GraphSig of the primal graph</li><li><code>GP_star::GraphPart</code>: GraphPart of the dual graph</li><li><code>VM_NGWP::Array{Float64,3}</code>: varimax NGWP.</li><li><code>PC_NGWP::Array{Float64,3}</code>: pair-clustering NGWP.</li><li><code>ùöΩ::Matrix{Float64}</code>: the matrix of graph Laplacian eigenvectors.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.getall_expansioncoeffs2-Tuple{GraphSig, GraphPart, GraphPart, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Matrix{Float64}, Matrix{Float64}}" href="#MultiscaleGraphSignalTransforms.getall_expansioncoeffs2-Tuple{GraphSig, GraphPart, GraphPart, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Matrix{Float64}, Matrix{Float64}}"><code>MultiscaleGraphSignalTransforms.getall_expansioncoeffs2</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>getall<em>expansioncoeffs2(G</em>Sig::GraphSig, GP<em>star::GraphPart,                                  GP</em>star<em>Lsym::GraphPart,                                  VM</em>NGWP::Array{Float64,3},                                  PC<em>NGWP::Array{Float64,3},                                  LP</em>NGWP::Array{Float64,3},                                  VM<em>NGWP</em>Lsym::Array{Float64,3},                                  PC<em>NGWP</em>Lsym::Array{Float64,3},                                  LP<em>NGWP</em>Lsym::Array{Float64,3},                                  ùöΩ::Matrix{Float64},                                  ùöΩsym::Matrix{Float64})</p><p>get all expansion coefficients of <code>f</code> in dissertation via all methods in NGWP.jl and MTSG.jl</p><p><strong>Input Arguments</strong></p><ul><li><code>G_Sig::GraphSig</code>: GraphSig of the primal graph</li><li><code>GP_star::GraphPart</code>: GraphPart of the dual graph</li><li><code>VM_NGWP::Array{Float64,3}</code>: varimax NGWP.</li><li><code>PC_NGWP::Array{Float64,3}</code>: pair-clustering NGWP.</li><li><code>LP_NGWP::Array{Float64,3}</code>: lapped NGWP.</li><li><code>VM_NGWP_Lsym::Array{Float64,3}</code>: Lsym version of varimax NGWP.</li><li><code>PC_NGWP_Lsym::Array{Float64,3}</code>: Lsym version of pair-clustering NGWP.</li><li><code>LP_NGWP_Lsym::Array{Float64,3}</code>: Lsym version of lapped NGWP.</li><li><code>ùöΩ::Matrix{Float64}</code>: the matrix of <code>L</code> eigenvectors.</li><li><code>ùöΩsym::Matrix{Float64}</code>: the matrix of <code>Lsym</code> eigenvectors.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.gplot-Tuple{SparseMatrixCSC{Float64, Int64}, Matrix{Float64}}" href="#MultiscaleGraphSignalTransforms.gplot-Tuple{SparseMatrixCSC{Float64, Int64}, Matrix{Float64}}"><code>MultiscaleGraphSignalTransforms.gplot</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gplot(A, xyz; plotp = true,
      style = :auto, width = 2, color = :blue,
      shape = :none, mwidth = 2, mcolor = color, malpha = 1.0,
      mscolor = color, mswidth = 1, msalpha = 1.0,
      grid::Bool = false, label = &quot;&quot;, subplot = 1)</code></pre><p>GPLOT Plot graph, as in graph theory. GPLOT(A,xyz,...) plots the graph specified by the adjacency matrix A and the node coordinates xyz. GPLOT!(A,xyz,...) adds a plot to <code>current</code> one.</p><p><strong>Input Arguments</strong></p><ul><li><code>A::SparseMatrixCSC{Float64,Int}</code>: the adjacency matrix of a graph <code>G</code></li><li><code>xyz::Matrix{Float64}</code>: The coordinates array, <code>xyz</code>, is an n-by-2 or n-by-3 matrix</li></ul><p>with the position for node i in the i-th row, xyz[i,:] = [x[i] y[i]] or xyz[i,:] = [x[i] y[i] z[i]].</p><ul><li><code>plotp::Bool</code>: if the plot is made (default) or return the X, Y, Z arrays</li><li><code>style::Symbol</code>: of line; choose from Symbol[:auto,:solid,:dash,:dot,:dashdot] (default: :auto)</li><li><code>width::Number</code>: of line in pixels (default: 2; fraction, e.g., 0.5 is allowed)</li><li><code>color::Symbol</code>: of line; choose from Symbol[:white,:blue,:red,:green,...] (default: :blue)</li><li><code>shape::Symbol</code>: choose from Symbol[:none,:auto,:circle,:rect,:star5,:diamond,                                     :hexagon,:cross,:xcross,:utriangle,                                     :dtriangle,:pentagon,:heptagon,:octagon,                                     :star4,:star6,:star7,:star8,:vline,:hline] (default: :none)</li><li><code>mwidth::Number</code>: marker size (or radius) in pixels (default: 2)</li><li><code>mcolor::Symbol</code>: of marker (default: the same as line color)</li><li><code>malpha::Float64</code>: opacity of marker interior; choose from [0,1] (default: 1.0)</li><li><code>mswidth::Number</code>: marker stroke size (width) in pixels (default: 1)</li><li><code>mscolor::Symbol</code>: of marker stroke (default: the same as line color)</li><li><code>msalpha::Float64</code>: opacity of marker stroke; choose from [0,1] (default: 1.0)</li><li><code>grid::Bool</code>: a flag to show grid lines (default: false)</li><li><code>label::String</code>: a string for legend (default: &quot;&quot;)</li><li><code>subplot::Int</code>: subplot index (default: 1)</li></ul><p><strong>Output Arguments</strong></p><ul><li><code>X::Matrix{Float64}</code>: Nan-punctuated X coordinate vector</li><li><code>Y::Matrix{Float64}</code>: Nan-punctuated Y coordinate vector</li><li><code>Z::Matrix{Float64}</code>: Nan-punctuated Z coordinate vector</li></ul><p>(X,Y)= GPLOT(A,xyz,plotp=false,...) or (X,Y,Z) = GPLOT(A,xyz,plotp=false,...) return the NaN-punctuated vectors X and Y or X, Y and Z without actually generating a plot. These vectors can be used to generate the plot at a later time with PLOT or PLOT3D if desired.</p><p>A backward-compatible elaboration of Mathworks&#39;s gplot that uses 3D data (if available) when the plot is rotated. Robert Piche, Tampere Univ. of Tech., 2005</p><p>Translated into julia by Naoki Saito, Dec. 21, 2016. Note that we should still consider the keywords organized as <code>function gplot(A,xyz,kw...)</code></p><p>Nicholas Hausch edits: Must install Plots package For 3D rotation, use <code>plotlyjs()</code> backend</p><p>Revised by Naoki Saito, Feb. 17, 2017 Revised by Naoki Saito, Oct. 13, 2017 Revised by Haotian Li, Jul. 25, 2018 Revised by Haotian Li and Naoki Saito for Julia v0.7/1.0, Sep. 21, 2018 Instead of plot(...), we decided to use Plots.plot(...) in order to avoid     the function name ambiguity; this is a safer approach. Revised by Naoki Saito, Oct. 22, 2018</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.heat_sol-NTuple{4, Any}" href="#MultiscaleGraphSignalTransforms.heat_sol-NTuple{4, Any}"><code>MultiscaleGraphSignalTransforms.heat_sol</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">heat_sol(f0,ùöΩ,Œ£,t)</code></pre><p>HEAT_SOL gives the solution of heat partial differential equation with initial condition u(‚ãÖ, 0) = f0</p><p><strong>Input Arguments</strong></p><ul><li><code>f0::Array{Float64}</code>: initial condition vector.</li><li><code>ùöΩ::Matrix{Float64}</code>: graph Laplacian eigenvectors, served as graph Fourier transform matrix</li><li><code>Œ£::Array{Int}</code>: diagonal matrix of eigenvalues.</li><li><code>t::Float</code>: time elapse.</li></ul><p><strong>Output Argument</strong></p><ul><li><code>u::Array{Float64}</code>: the solution vector at time t</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.ind_class-Tuple{Int64}" href="#MultiscaleGraphSignalTransforms.ind_class-Tuple{Int64}"><code>MultiscaleGraphSignalTransforms.ind_class</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">T = ind_class(N::Int)

Given `N`, determine what class `ind` (and `rs`) should be</code></pre><p><strong>Input Argument</strong></p><ul><li><code>N::Int</code>: the length of the graph signal</li></ul><p><strong>Output Argument</strong></p><ul><li><code>T &lt;: Unsigned</code>: the unsigned integer class that <code>ind</code> should be</li></ul><p>Copyright 2015 The Regents of the University of California</p><p>Implemented by Jeff Irion (Adviser: Dr. Naoki Saito) | Translated and revised by Naoki Saito, Feb. 8, 2017</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.levlist2levlengths!-Tuple{GraphPart, BasisSpec}" href="#MultiscaleGraphSignalTransforms.levlist2levlengths!-Tuple{GraphPart, BasisSpec}"><code>MultiscaleGraphSignalTransforms.levlist2levlengths!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">levlist2levlengths!(GP::GraphPart, BS::BasisSpec)</code></pre><p>Compute the levlengths info for a BasisSpec object</p><p><strong>Input Arguments</strong></p><ul><li><code>GP::GraphPart</code>: a GraphPart object</li><li><code>BS::BasisSpec</code>: BasisSpec object, without <code>levlengths</code>; after this function, the <code>levlengths</code> field is filled.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.lp_ngwp-Tuple{Matrix{Float64}, SparseMatrixCSC{Float64, Int64}, GraphPart}" href="#MultiscaleGraphSignalTransforms.lp_ngwp-Tuple{Matrix{Float64}, SparseMatrixCSC{Float64, Int64}, GraphPart}"><code>MultiscaleGraphSignalTransforms.lp_ngwp</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lp_ngwp(ùöΩ::Matrix{Float64}, W_dual::SparseMatrixCSC{Float64, Int64},
        GP_dual::GraphPart; œµ::Float64 = 0.3)</code></pre><p>construct the lapped NGWP and GP.tag in place.</p><p><strong>Input Arguments</strong></p><ul><li><code>ùöΩ::Matrix{Float64}</code>: graph Laplacian eigenvectors</li><li><code>W_dual::SparseMatrixCSC{Float64, Int64}</code>: weight matrix of the dual graph</li><li><code>GP_dual::GraphPart</code>: GraphPart object of the dual graph</li></ul><p><strong>Output Argument</strong></p><ul><li><code>wavelet_packet::Array{Float64,3}</code>: the lapped NGWP dictionary. The first   index is for selecting wavelets at a fixed level; the second index is for   selecting the level <code>j</code>; the third index is for selecting elements in the   wavelet vector.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.lp_ngwp_analysis-Tuple{GraphSig, Matrix{Float64}, SparseMatrixCSC{Float64, Int64}, GraphPart}" href="#MultiscaleGraphSignalTransforms.lp_ngwp_analysis-Tuple{GraphSig, Matrix{Float64}, SparseMatrixCSC{Float64, Int64}, GraphPart}"><code>MultiscaleGraphSignalTransforms.lp_ngwp_analysis</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lp_ngwp_analysis(G::GraphSig, ùöΩ::Matrix{Float64}, W_dual::SparseMatrixCSC{Float64, Int64},
        GP_dual::GraphPart; œµ::Float64 = 0.3)</code></pre><p>perform the LP-NGWP transform of the graph signal(s) <code>G.f</code>.</p><p><strong>Input Arguments</strong></p><ul><li><code>G::GraphSig</code>: a GraphSig object</li><li><code>ùöΩ::Matrix{Float64}</code>: graph Laplacian eigenvectors</li><li><code>W_dual::SparseMatrixCSC{Float64, Int64}</code>: weight matrix of the dual graph</li><li><code>GP_dual::GraphPart</code>: GraphPart object of the dual graph</li></ul><p><strong>Output Argument</strong></p><ul><li><code>wavelet_packet::Array{Float64,3}</code>: the lapped NGWP dictionary. The first   index is for selecting wavelets at a fixed level; the second index is for   selecting the level <code>j</code>; the third index is for selecting elements in the   wavelet vector.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.mgslp-Tuple{Matrix{Float64}}" href="#MultiscaleGraphSignalTransforms.mgslp-Tuple{Matrix{Float64}}"><code>MultiscaleGraphSignalTransforms.mgslp</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mgslp(A::Matrix{Float64}; tol::Float64 = 1e-12, p::Float64 = 1.0)</code></pre><p>Modified Gram-Schmidt Process Orthogonalization with ‚Ñì·µñ pivoting algorithm (MGSLp)</p><p><strong>Input Arguments</strong></p><ul><li><code>A::Matrix{Float64}</code>: whose column vectors are to be orthogonalized.</li></ul><p><strong>Output Argument</strong></p><ul><li><code>A::Matrix{Float64}</code>: orthogonalization matrix of A&#39;s column vectors based on ‚Ñì·µñ pivoting.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.nat_spec_filter-Tuple{Any, Any}" href="#MultiscaleGraphSignalTransforms.nat_spec_filter-Tuple{Any, Any}"><code>MultiscaleGraphSignalTransforms.nat_spec_filter</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nat_spec_filter(l, D; œÉ = 0.25 * maximum(D), method = :regular, thres = 0.2)</code></pre><p>assemble the natural spectral graph filter centered at the l-th eigenvector via the distance matrix <code>D</code>.</p><p><strong>Input Arguments</strong></p><ul><li><code>l::Int64</code>: index of the centered eigenvector</li><li><code>D::Matrix{Float64}</code>: non-trivial distance matrix of the eigenvectors</li><li><code>œÉ::Float64</code>: Gaussian window width parameter (default: <code>0.25 * maximum(D)</code>)</li><li><code>method::Symbol</code>: <code>:regular</code> or <code>:reduced</code> (default: <code>:regular</code>)</li><li><code>thres::Float64</code>: cutoff threshold ‚àà (0, 1).</li></ul><p><strong>Output Argument</strong></p><ul><li><code>ùõç::Vector{Float64}</code>: the natural spectral graph filter</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.natural_eigdist-Tuple{Any, Any, Any}" href="#MultiscaleGraphSignalTransforms.natural_eigdist-Tuple{Any, Any, Any}"><code>MultiscaleGraphSignalTransforms.natural_eigdist</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">natural_eigdist(ùöΩ, ùõå, Q; Œ± = 1.0, T = :Inf,
                input_format = :zero_measures, distance = :DAG,
                edge_weight = 1, edge_length = 1)</code></pre><p>compute natural distances between graph Laplacian eigenvectors.</p><p><strong>Input Arguments</strong></p><ul><li><code>ùöΩ::Matrix{Float64}</code>: matrix of (weighted) graph Laplacian eigenvectors.</li><li><code>ùõå::Vector{Float64}</code>: vector of eigenvalues.</li><li><code>Q::Matrix{Float64}</code>: unweighted incidence matrix of the graph.</li><li><code>Œ±::Float64</code>: ROT parameter. (default: <code>1.0</code>)</li><li><code>T::Any</code>: TSD parameter, i.e., the stopping time T in K_functional (default: <code>:Inf</code>)</li><li><code>input_format::Symbol</code>: options: <code>:zero_measures</code>, <code>:pmf1</code> and <code>:pmf2</code> (default: <code>:zero_measures</code>)</li><li><code>distance::Symbol</code>: options: <code>:ROT</code>, <code>:HAD</code>, <code>:DAG</code> and <code>:TSD</code> (default: <code>:DAG</code>)</li><li><code>edg_length::Any</code>: vector of edge lengths (default: 1 represents unweighted graphs)</li><li><code>edge_weight::Any</code>: the weights vector, which stores the affinity weight of   each edge (default: <code>1</code> represents unweighted graphs).</li></ul><p><strong>Output Argument</strong></p><ul><li><code>dis::Matrix{Float64}</code>: the distance matrix, dis[i,j] = d(ùúô·µ¢‚Çã‚ÇÅ, ùúô‚±º‚Çã‚ÇÅ).</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.ngwf_all_vectors-Tuple{Any, Any}" href="#MultiscaleGraphSignalTransforms.ngwf_all_vectors-Tuple{Any, Any}"><code>MultiscaleGraphSignalTransforms.ngwf_all_vectors</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ngwf_all_vectors(D, ùöΩ; œÉ = 0.2 * maximum(D))</code></pre><p>assemble the whole NGWF dictionary.</p><p><strong>Input Arguments</strong></p><ul><li><code>D::Matrix{Float64}</code>: non-trivial distance matrix of the eigenvectors</li><li><code>ùöΩ::Matrix{Float64}</code>: graph Laplacian eigenvectors</li><li><code>œÉ::Float64</code>: Gaussian window width parameter (default: <code>0.25 * maximum(D)</code>)</li></ul><p><strong>Output Argument</strong></p><ul><li><code>ùì§::Matrix{Float64}</code>: the NGWF dictionary</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.ngwp_analysis-Tuple{GraphSig, Array{Float64, 3}}" href="#MultiscaleGraphSignalTransforms.ngwp_analysis-Tuple{GraphSig, Array{Float64, 3}}"><code>MultiscaleGraphSignalTransforms.ngwp_analysis</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ngwp_analysis(G::GraphSig, wavelet_packet::Array{Float64,3})</code></pre><p>For a GraphSig object <code>G</code>, generate the matrix of NGWP expansion coefficients.</p><p><strong>Input Arguments</strong></p><ul><li><code>G::GraphSig</code>: an input GraphSig object</li><li><code>wavelet_packet::Array{Float64,3}</code>: the varimax wavelets packet.</li></ul><p><strong>Output Argument</strong></p><ul><li><code>dmatrix::Array{Float64,3}</code>: the expansion coefficients matrix.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.ngwp_bestbasis-Tuple{Array{Float64, 3}, GraphPart}" href="#MultiscaleGraphSignalTransforms.ngwp_bestbasis-Tuple{Array{Float64, 3}, GraphPart}"><code>MultiscaleGraphSignalTransforms.ngwp_bestbasis</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(dvec_ngwp, BS_ngwp) = ngwp_bestbasis(dmatrix::Array{Float64,3}, GP_star::GraphPart;
                                      cfspec::Any = 1.0, flatten::Any = 1.0,
                                      j_start::Int = 1, j_end::Int = size(dmatrix, 2),
                                      useParent::Bool = true)</code></pre><p>Select the best basis from the matrix of NGWP expansion coefficients.</p><p><strong>Input Arguments</strong></p><ul><li><code>dmatrix::Array{Float64,3}</code>: the matrix of expansion coefficients</li><li><code>GP_star::GraphPart</code>: an input GraphPart object of the dual graph</li><li><code>cfspec::Any</code>: the specification of cost functional to be used (default = 1.0,   i.e., 1-norm)</li><li><code>flatten::Any</code>: the method for flattening vector-valued data to scalar-valued   data (default = 1.0, i.e, 1-norm)</li><li><code>useParent::Bool</code>: the flag to indicate if we update the selected best basis   subspace to the parent when parent and child have the same cost (default = false)</li></ul><p><strong>Output Arguments</strong></p><ul><li><code>dvec_ngwp::Matrix{Float64}</code>: the vector of expansion coefficients corresponding   to the NGWP best basis</li><li><code>BS_ngwp::BasisSpec</code>: a BasisSpec object which specifies the NGWP best basis</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.nonorth2relerror-Tuple{Vector{Float64}, Matrix{Float64}}" href="#MultiscaleGraphSignalTransforms.nonorth2relerror-Tuple{Vector{Float64}, Matrix{Float64}}"><code>MultiscaleGraphSignalTransforms.nonorth2relerror</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>function nonorth2relerror(nonorth::array{Float64,1},B::array{Float64,2})</p><p>Given a vector &#39;nonorth&#39; of non-orthonormal expansion coefficients and the matrix &#39;B&#39; such that B*nonorth is the original signal, return a vector of relative approximation errors when retaining the 1,2,...,N largest coefficients in magnitude.</p><p><strong>Input argument</strong></p><ul><li><code>nonorth</code>:    a vector of non-orthonormal expansion coefficients</li><li><code>B</code>:          the matrix whose such that B*nonorth is the original signal</li></ul><p><strong>Output argument</strong></p><ul><li><code>relerror</code>:   a vector of relative approximation errors</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.orth2relerror-Tuple{Vector{Float64}}" href="#MultiscaleGraphSignalTransforms.orth2relerror-Tuple{Vector{Float64}}"><code>MultiscaleGraphSignalTransforms.orth2relerror</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>function orth2relerror(orth)</p><p>Given a vector &#39;orth&#39; of orthonormal expansion coefficients, return a vector of relative approximation errors when retaining the 1,2,...,N largest coefficients in magnitude.</p><p><strong>Input argument</strong></p><ul><li><code>orth</code>:    a vector of orthonormal expansion coefficients</li></ul><p><strong>Output argument</strong></p><ul><li><code>relerror</code>:   a vector of relative approximation errors</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.pairclustering-Tuple{Matrix{Float64}, GraphPart}" href="#MultiscaleGraphSignalTransforms.pairclustering-Tuple{Matrix{Float64}, GraphPart}"><code>MultiscaleGraphSignalTransforms.pairclustering</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pairclustering(ùöΩ::Matrix{Float64}, GP_star::GraphPart)</code></pre><p>construct the GraphPart object of the primal graph via pair-clustering algorithm.</p><p><strong>Input Arguments</strong></p><ul><li><code>ùöΩ::Matrix{Float64}</code>: graph Laplacian eigenvectors ùöΩ</li><li><code>GP_star::GraphPart</code>: GraphPart object of the dual graph</li></ul><p><strong>Output Argument</strong></p><ul><li><code>GP::GraphPart</code>: GraphPart object of the primal graph via pair-clustering</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.partition_fiedler-Tuple{SparseMatrixCSC{Float64, Int64}}" href="#MultiscaleGraphSignalTransforms.partition_fiedler-Tuple{SparseMatrixCSC{Float64, Int64}}"><code>MultiscaleGraphSignalTransforms.partition_fiedler</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(pm,v) = partition_fiedler(W; method, v)</code></pre><p>Partition the vertices of a graph according to the Fiedler vector</p><p><strong>Input Arguments</strong></p><ul><li><code>W::SparseMatrixCSC{Float64,Int}</code>: the edge weight matrix</li><li><code>method::Symbol</code>: the parition method to be used (:L or :Lrw or else ...)</li><li><code>v::Vector{Float64}</code>: the Fiedler vector supplied if <code>v</code> is a null vector</li></ul><p><strong>Output Arguments</strong></p><ul><li><code>pm::Vector{Int}</code>: a vector of 1&#39;s and -1&#39;s</li><li><code>v::Vector{Float64}</code>: the Fiedler vector used for graph partitioning</li></ul><p>Copyright 2015 The Regents of the University of California</p><p>Implemented by Jeff Irion (Adviser: Dr. Naoki Saito) Translated and revised by Naoki Saito, Feb. 9, 2017</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.partition_fiedler_pm-Tuple{Vector{Float64}}" href="#MultiscaleGraphSignalTransforms.partition_fiedler_pm-Tuple{Vector{Float64}}"><code>MultiscaleGraphSignalTransforms.partition_fiedler_pm</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(pm, v) = partition_fiedler_pm(v::Vector{Float64})

Partition an input Graph based on the Fiedler vector `v`</code></pre><p><strong>Input Argument</strong></p><ul><li><code>v::Vector{Float64}</code>: the input Fiedler vector</li></ul><p><strong>Output Arguments</strong></p><ul><li><code>pm::Vector{Int}</code>: the partition info</li><li><code>v::Vector{Float64}</code>: the output Fiedler vector if requested</li></ul><p>Copyright 2015 The Regents of the University of California</p><p>Implemented by Jeff Irion (Adviser: Dr. Naoki Saito) Translated and revised by Naoki Saito, Feb. 10, 2017</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.partition_fiedler_troubleshooting-Tuple{Vector{Int64}, Vector{Float64}, SparseMatrixCSC{Float64, Int64}, Float64}" href="#MultiscaleGraphSignalTransforms.partition_fiedler_troubleshooting-Tuple{Vector{Int64}, Vector{Float64}, SparseMatrixCSC{Float64, Int64}, Float64}"><code>MultiscaleGraphSignalTransforms.partition_fiedler_troubleshooting</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pm = partition_fiedler_troubleshooting(pm,v,W,val)</code></pre><p>Troubleshoot potential issues with the partitioning</p><p><strong>Input Arguments</strong></p><ul><li><code>pm::Vector{Int}</code>: an input partition info (+1 or -1) of each node</li><li><code>v::Vector{Float64}</code>: the Fiedler vector of the graph</li><li><code>W::SparseMatrixCSC{Float64,Int}</code>: an input edge weight matrix</li><li><code>val::Float64</code>: the algebraic connectivity (i.e., <span>$\lambda_2$</span>)</li></ul><p><strong>Ouput Arguments</strong></p><ul><li><code>pm::Vector{Int}</code>: a final partition info vector</li></ul><p>Copyright 2015 The Regents of the University of California</p><p>Implemented by Jeff Irion (Adviser: Dr. Naoki Saito) Translated and revised by Naoki Saito, Feb. 10, 2017</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.partition_fiedler_troubleshooting-Tuple{Vector{Int64}}" href="#MultiscaleGraphSignalTransforms.partition_fiedler_troubleshooting-Tuple{Vector{Int64}}"><code>MultiscaleGraphSignalTransforms.partition_fiedler_troubleshooting</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pm = partition_fiedler_troubleshooting(pm)</code></pre><p>Troubleshoot potential issues with the partitioning</p><p><strong>Input Arguments</strong></p><ul><li><code>pm::Vector{Int}</code>: an input partition info (+1 or -1) of each node</li></ul><p><strong>Ouput Arguments</strong></p><ul><li><code>pm::Vector{Int}</code>: a final partition info vector</li></ul><p>Copyright 2015 The Regents of the University of California</p><p>Implemented by Jeff Irion (Adviser: Dr. Naoki Saito) Translated and revised by Naoki Saito, Feb. 10, 2017</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.partition_pc-Tuple{Matrix{Float64}, Vector{Int64}, Vector{Int64}, Vector{Int64}}" href="#MultiscaleGraphSignalTransforms.partition_pc-Tuple{Matrix{Float64}, Vector{Int64}, Vector{Int64}, Vector{Int64}}"><code>MultiscaleGraphSignalTransforms.partition_pc</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">partition_pc(ùöΩ::Matrix{Float64}, indrs::Vector{Int}, indrs_dual1::Vector{Int}, indrs_dual2::Vector{Int})</code></pre><p>based on the partition on dual graph, partition the primal graph region (indexed by <code>indrs</code>) into two pieces via the pair-clustering algorithm.</p><p><strong>Input Arguments</strong></p><ul><li><code>ùöΩ::Matrix{Float64}</code>: graph Laplacian eigenvectors ùöΩ</li><li><code>indrs::Vector{Int}</code>: indices of the primal graph region to be partitioned</li><li><code>indrs_dual1::Vector{Int}</code>: index1 of the dual graph region&#39;s partition result</li><li><code>indrs_dual2::Vector{Int}</code>: index2 of the dual graph region&#39;s partition result</li></ul><p><strong>Output Argument</strong></p><ul><li><code>indp1::Vector{Int}</code>: index1 of <code>indrs</code> for the partition result</li><li><code>indp2::Vector{Int}</code>: index2 of <code>indrs</code> for the partition result</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.pc_ngwp-Tuple{Matrix{Float64}, GraphPart, GraphPart}" href="#MultiscaleGraphSignalTransforms.pc_ngwp-Tuple{Matrix{Float64}, GraphPart, GraphPart}"><code>MultiscaleGraphSignalTransforms.pc_ngwp</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pc_ngwp(ùöΩ::Matrix{Float64}, GP_star::GraphPart, GP::GraphPart)</code></pre><p>construct pair-clustering NGWP and GP.tag in place.</p><p><strong>Input Arguments</strong></p><ul><li><code>ùöΩ::Matrix{Float64}</code>: graph Laplacian eigenvectors ùöΩ</li><li><code>GP_star::GraphPart</code>: GraphPart object of the dual graph</li><li><code>GP::GraphPart</code>: GraphPart object of the primal graph</li></ul><p><strong>Output Argument</strong></p><ul><li><code>wavelet_packet::Array{Float64,3}</code>: the pair-clustering NGWP. The first   index is for selecting wavelets at a fixed level; the second index is for   selecting the level <code>j</code>; the third index is for selecting elements in the   wavelet vector.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.rngwf_all_vectors-Tuple{Any, Any}" href="#MultiscaleGraphSignalTransforms.rngwf_all_vectors-Tuple{Any, Any}"><code>MultiscaleGraphSignalTransforms.rngwf_all_vectors</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rngwf_all_vectors(D, ùöΩ; œÉ = 0.2 * maximum(D), thres = 0.2)</code></pre><p>assemble the reduced NGWF (rNGWF) dictionary.</p><p><strong>Input Arguments</strong></p><ul><li><code>D::Matrix{Float64}</code>: non-trivial distance matrix of the eigenvectors</li><li><code>ùöΩ::Matrix{Float64}</code>: graph Laplacian eigenvectors</li><li><code>œÉ::Float64</code>: Gaussian window width parameter (default: <code>0.25 * maximum(D)</code>)</li><li><code>thres::Float64</code>: cutoff threshold ‚àà (0, 1).</li></ul><p><strong>Output Argument</strong></p><ul><li><code>ùì§::Matrix{Float64}</code>: the rNGWF dictionary</li><li><code>dic_l2x::Dict</code>: a dictionary to store the filtered locations by QR at the l-th   centered eigenvector</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.rngwf_lx-Tuple{Any}" href="#MultiscaleGraphSignalTransforms.rngwf_lx-Tuple{Any}"><code>MultiscaleGraphSignalTransforms.rngwf_lx</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rngwf_lx(dic_l2x)</code></pre><p>find the sequential subindices of rNGWF vectors.</p><p><strong>Input Arguments</strong></p><ul><li><code>dic_l2x::Dict</code>: a dictionary to store the filtered locations by QR at the l-th   centered eigenvector</li></ul><p><strong>Output Argument</strong></p><ul><li><code>Œì::Vector{Tuple{Int64,Int64}}</code>: the sequential subindices of rNGWF vectors.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.rs_to_region-Tuple{Matrix{Int64}, Matrix{Int64}}" href="#MultiscaleGraphSignalTransforms.rs_to_region-Tuple{Matrix{Int64}, Matrix{Int64}}"><code>MultiscaleGraphSignalTransforms.rs_to_region</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function rs_to_region(rs::Matrix{Any}, tag::Matrix{Any})</code></pre><p>From the imformation of rs, tag from GP, compute the tag_r matrix, which have the same size of dmatrix (expansion coefficient matrix). Each element indicates the place of the coefficient in the expansion tree.</p><p><strong>Input Arguments</strong></p><ul><li><code>rs::Matrix{Any}</code>: rs from GP, showing information of the partition tree</li><li><code>tag::Matrix{Any}</code>: tag from GP, indicating coefficients tag</li></ul><p><strong>Output Arguments</strong></p><ul><li><code>tag_r::Matrix{UInt64}</code>: showing information of the partition tree, same size as dmatrix</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.scatter_gplot-Tuple{Any}" href="#MultiscaleGraphSignalTransforms.scatter_gplot-Tuple{Any}"><code>MultiscaleGraphSignalTransforms.scatter_gplot</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">scatter_gplot(X; marker = nothing, ms = 4, plotOrder = :normal, c = :viridis, subplot = 1)</code></pre><p>SCATTER_GPLOT generates a scatter plot figure, which is for quick viewing of a graph signal. SCATTER_GPLOT!(X; ...) adds a plot to <code>current</code> one.</p><p><strong>Input Arguments</strong></p><ul><li><code>X::Matrix{Float64}</code>: points locations, can be 2-dim or 3-dim.</li><li><code>marker::Array{Float64}</code>: default is nothing. Present different colors given   different signal value at each node.</li><li><code>ms::Array{Float64}</code>: default is 4. Present different node sizes given   different signal value at each node.</li><li><code>plotOrder::Symbol</code>: default is normal. Optional choices :s2l or :l2s, i.e.,   plots from the smallest value of <code>marker</code> to the largest value or the other way around.</li><li><code>c::Symbol</code>: default is :viridis. Colors.</li><li><code>subgplot::Int</code>: default is 1. The subplot index.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.sort_wavelets-Tuple{Any}" href="#MultiscaleGraphSignalTransforms.sort_wavelets-Tuple{Any}"><code>MultiscaleGraphSignalTransforms.sort_wavelets</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sort_wavelets(A; onlyByLoc = false)</code></pre><p>sort A&#39;s column wavelet vectors based on their focused nodes&#39; indices. flip signs via the cross correlation.</p><p><strong>Input Arguments</strong></p><ul><li><code>A::Matrix{Float64}</code>: whose column vectors are wavelets.</li></ul><p><strong>Output Argument</strong></p><ul><li><code>A::Matrix{Float64}</code>: a matrix with sorted and sign flipped column.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.spectral_clustering-Tuple{Any, Any}" href="#MultiscaleGraphSignalTransforms.spectral_clustering-Tuple{Any, Any}"><code>MultiscaleGraphSignalTransforms.spectral_clustering</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">spectral_clustering(ùöΩ, M)</code></pre><p>SPECTRAL_CLUSTERING return M graph clusters, i.e., {V‚Çñ| k = 1,2,...,M}.</p><p><strong>Input Argument</strong></p><ul><li><code>ùöΩ::Matrix{Float64}</code>: the matrix of graph Laplacian eigenvectors.</li><li><code>M::Int</code>: the number of graph clusters.</li></ul><p><strong>Output Argument</strong></p><ul><li><code>clusters::Vector{Vector{Int}}</code>: graph cluster indices.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.spike-Tuple{Any, Any}" href="#MultiscaleGraphSignalTransforms.spike-Tuple{Any, Any}"><code>MultiscaleGraphSignalTransforms.spike</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">spike(i, N)</code></pre><p>SPIKE gives the N-dim spike vector with i-th element equals 1.</p><p><strong>Input Arguments</strong></p><ul><li><code>i::Int</code>: index for one.</li><li><code>N::Int</code>: dimension of the target spike vector.</li></ul><p><strong>Output Argument</strong></p><ul><li><code>v::Array{Float64}</code>: the N-dim spike vector with i-th element equals 1.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.standardize_eigenvectors!-Tuple{Matrix{Float64}}" href="#MultiscaleGraphSignalTransforms.standardize_eigenvectors!-Tuple{Matrix{Float64}}"><code>MultiscaleGraphSignalTransforms.standardize_eigenvectors!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">standardize_eigenvectors!(ùöΩ::Matrix{Float64})</code></pre><p>standardize the signs of the eigenvectors such that 1) the term with the largest magnitude is positive; 2) if the max == -min, then make sure the first non-zero entry of the eigenvector is positive.</p><p><strong>Input Arguments</strong></p><ul><li><code>ùöΩ::Matrix{Float64}</code>: matrix of graph Laplacian eigenvectors</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.tag_class-Tuple{Int64}" href="#MultiscaleGraphSignalTransforms.tag_class-Tuple{Int64}"><code>MultiscaleGraphSignalTransforms.tag_class</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">T = tag_class(jmax::Int)</code></pre><p>Given <code>jmax</code>, determine what class <code>tag</code> should be.</p><p><strong>Input Argument</strong></p><ul><li><code>jmax::Int</code>: the number of levels in the recursive partitioning (j = 1:jmax)</li></ul><p><strong>Output Argument</strong></p><ul><li><code>T &lt;: Unsigned</code>: the unsigned integer class that <code>tag</code> should be</li></ul><p>Copyright 2015 The Regents of the University of California</p><p>Implemented by Jeff Irion (Adviser: Dr. Naoki Saito) | Translated and revised by Naoki Saito, Feb. 8, 2017</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.transform2D-Tuple{Any}" href="#MultiscaleGraphSignalTransforms.transform2D-Tuple{Any}"><code>MultiscaleGraphSignalTransforms.transform2D</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform2D(X; s = 1, t = [0,0])</code></pre><p>TRANSFORM2D dilate each point of <code>X</code> by scale s and translate by 2D vector t.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.varimax-Tuple{Any}" href="#MultiscaleGraphSignalTransforms.varimax-Tuple{Any}"><code>MultiscaleGraphSignalTransforms.varimax</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">varimax(A; gamma = 1.0, minit = 20, maxit = 1000, reltol = 1e-12)</code></pre><p>VARIMAX perform varimax (or quartimax, equamax, parsimax) rotation to the column vectors of the input matrix.</p><p><strong>Input Arguments</strong></p><ul><li><code>A::Matrix{Float64}</code>: input matrix, whose column vectors are to be rotated. d, m = size(A).</li><li><code>gamma::Float64</code>: default is 1. gamma = 0, 1, m/2, and d(m - 1)/(d + m - 2), corresponding to quartimax, varimax, equamax, and parsimax.</li><li><code>minit::Int</code>: default is 20. Minimum number of iterations, in case of the stopping criteria fails initially.</li><li><code>maxit::Int</code>: default is 1000. Maximum number of iterations.</li><li><code>reltol::Float64</code>: default is 1e-12. Relative tolerance for stopping criteria.</li></ul><p><strong>Output Argument</strong></p><ul><li><code>B::Matrix{Float64}</code>: output matrix, whose columns are already been rotated.</li></ul><p>Implemented by Haotian Li, Aug. 20, 2019</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiscaleGraphSignalTransforms.vm_ngwp-Tuple{Matrix{Float64}, GraphPart}" href="#MultiscaleGraphSignalTransforms.vm_ngwp-Tuple{Matrix{Float64}, GraphPart}"><code>MultiscaleGraphSignalTransforms.vm_ngwp</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vm_ngwp(ùöΩ::Matrix{Float64}, GP_star::GraphPart)</code></pre><p>construct varimax NGWP and GP_star.tag in place.</p><p><strong>Input Arguments</strong></p><ul><li><code>ùöΩ::Matrix{Float64}</code>: graph Laplacian eigenvectors ùöΩ</li><li><code>GP_star::GraphPart</code>: GraphPart object of the dual graph</li></ul><p><strong>Output Argument</strong></p><ul><li><code>wavelet_packet::Array{Float64,3}</code>: the varimax NGWP. The first index is for   selecting wavelets at a fixed level; the second index is for selecting the   level <code>j</code>; the third index is for selecting elements in the wavelet vector.</li></ul></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">¬´ Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 17 May 2021 16:26">Monday 17 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
